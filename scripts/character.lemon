//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	if (char.character == CHARACTER_SONIC)
	{
		u8 input_pressed = control.player1.pressed
		if ((input_pressed & CONTROL_B) == 0 && (input_pressed & CONTROL_C) == 0)
			return false

		D0 = char.rotation
		if (global.inv_gravity)
		{
			D0.s8 = -D0.s8
		}
		else
		{
			D0.s8 += 0x80
		}

		pushA456()
		fn00f72e()
		popA456()

		if (D1.s16 < 6)
			return false

		// Get jump acceleration depending on character
		u16 acceleration
		if (char.character != CHARACTER_KNUCKLES || competition_mode.active)
		{
			if (char.flags & char.flag.UNDERWATER)
			{
				acceleration = 0x380
			}
			else if (super.active && char.character == CHARACTER_SONIC)
			{
				acceleration = 0x800
			}
			else
			{
				acceleration = 0x680
			}
		}
		else
		{
			if (char.flags & char.flag.UNDERWATER)
			{
				acceleration = 0x300
			}
			else
			{
				acceleration = 0x600
			}
		}

		u8 angle = char.rotation - 0x40
		s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
		s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

		char.velocity.x += accel_x
		char.velocity.y += accel_y

		char.flags |= char.flag.IN_AIR
		char.flags &= ~char.flag.PUSHING

		char.jumping = 1
		char.on_convex_surface = 0

		playSound(SFX_JUMP)

		char.hitbox_extends.x = char.hitbox.default.x
		char.hitbox_extends.y = char.hitbox.default.y
		char.flags &= ~char.flag.ROLLING
		char.state = char.state.TEJUMP

		s8 dy = s8(char.hitbox_extends.y) - s8(char.hitbox.default.y)
		char.position.y.u16 += global.inv_gravity ? dy : -dy

	#if STANDALONE
		// Glitch fix for Knuckles being unable to jump off underwater objects
		//  -> Move him up a single pixel up so he won't stick to objects
		// TODO: Does not work for the HCZ snake platforms
		if (acceleration <= 0x300 && (char.flags & char.flag.ON_OBJECT))
		{
			--char.position.y.u16
		}
	#endif
		return true
	}
	else
	{
		return base.Character.CheckStartJump()
	}
}

function void Character.updateJumpMoves()
{
	if (char.character == CHARACTER_SONIC)
	{
		u8 input_state     = control.player1.state
		u8 input_pressed   = control.player1.pressed
		bool isSuperActive = super.active

		if (char.jumping)
		{
			// Limit velocity.y
			s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
			if (char.velocity.y < max_vy)
			{
				// Limit vertical velocity while not pressing any jump button
				//  -> This is important to support low jumps by just tapping the button briefly
				if ((input_state & CONTROL_ABC) == 0)
				{
					char.velocity.y = max_vy
				}
			}
			else
			{
				if (char.double_jump_state == 0)
				{
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}

					// Check if pressed jump again in mid-air
					if (input_pressed & CONTROL_A)
					{
						// Check for other things to do instead of the usual reaction to jump button pressed
						if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
						{
							if (char.character == CHARACTER_SONIC)
							{
								SonicPressedJumpInMidAir()
							}
						}
					}
				}
			}
		}
		else
		{
			if (char.spindash == 0)
			{
				char.velocity.y = max(char.velocity.y, -0x0fc0)
			}
		}
	}
	else
	{
		base.Character.updateJumpMoves()
	}
}

function void SonicPressedJumpInMidAir()
{
	if (char.character == CHARACTER_SONIC)
	{
		// Remove control lock
		char.flags &= ~char.flag.CONTROL_LOCK
	#if STANDALONE
		char.double_jump_state = 1	// Always set this flag; needed for Drop Dash
	#endif

	#if STANDALONE
		if ((super.active && Game.getSetting(SETTING_SUPER_SONIC_ABILITY) != 1) || (super.active & 0x80))
	#else
		if (super.active)
	#endif
		{
			bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
			bool performHyperDash = isHyperSonic
			u8 input = control.player1.state & CONTROL_DPAD		// Only directions

		#if STANDALONE
			if (Game.getSetting(SETTING_SUPER_SONIC_ABILITY) == 2)
			{
				performHyperDash = (super.active)				// This allows Super Sonic to use the dash as well
			}

			if (performHyperDash && Game.getSetting(SETTING_HYPER_DASH_CONTROLS) == 1)
			{
				// Hyper Dash requires also pressing D-pad in any direction
				//  -> To allow for Drop Dashing without activating the Hyper Dash before
				performHyperDash = (input != 0)
			}
		#endif

			if (performHyperDash)
			{
			#if STANDALONE
				if (isHyperSonic)	// Super Sonic's dash does not cause a screen flash
			#endif
				{
					Character.ClearEnemiesOnScreen()
				}

				camera.locktime.player1 = 0x2000
				ClearPositionBackup()

				char.double_jump_state = 1
			#if STANDALONE
				if (!isHyperSonic)
					u8[0xffffcbc0 + 0x20] = 1
				else
			#endif
					u8[0xffffcd7c + 0x20] = 1

				playSound(SFX_SPINDASH_RELEASE)

				if (input != 0 && input < 0x0b)		// Not left and right at the same time
				{
					// Perform Hyper Dash
					A1 = 0x011afa + input * 4
					char.velocity.x = s16[A1]
					char.velocity.y = s16[A1+2]
				}
				else
				{
					char.velocity.x = (char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800
					char.velocity.y = 0
				}

			#if STANDALONE
				if (!isHyperSonic)
				{
					// Reduce dash speed for Super Sonic
					char.velocity.x = (char.velocity.x > 0) ? (char.velocity.x - 0x200) : (char.velocity.x < 0) ? (char.velocity.x + 0x200) : 0
					char.velocity.y = (char.velocity.y > 0) ? (char.velocity.y - 0x200) : (char.velocity.y < 0) ? (char.velocity.y + 0x200) : 0
				}
			#endif

				char.groundspeed = char.velocity.x
			}
			else
			{
				char.double_jump_state = 1
			}
		}
	#if STANDALONE
		else if ((char.bonus_effect & char.bonus.INVINCIBLE) && (Game.getSetting(SETTING_SUPER_SONIC_ABILITY) != 1 && !super.active))
	#else
		else if (char.bonus_effect & char.bonus.INVINCIBLE)
	#endif
		{
			// No reaction
		}
		else if (char.bonus_effect & char.bonus.SHIELD_FIRE)
		{
			// sorry nothing
		}
		else if (char.bonus_effect & char.bonus.SHIELD_LIGHTNING)
		{
			// error! see you later!!
		}
		else if (char.bonus_effect & char.bonus.SHIELD_BUBBLE)
		{

		}
		else
		{
			
		}
	}
	else
	{
		base.SonicPressedJumpInMidAir()
	}
}

function void Character.updateUprightOnGroundInner()
{
	base.Character.updateUprightOnGroundInner()
	if (char.character == CHARACTER_SONIC)
	{
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_A)
		{
			Character.DoTEKick()
		}
	}
}

//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if (char.character == CHARACTER_SONIC)
	{
		u8 input_state = control.player1.state
		s16 vx = char.velocity.x

		s16 maxSpeed = s16[A4]
		s16 acceleration = s16[A4 + 2] * 2
		
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_A)
		{
			Character.DoTEKick()
		}

		if (input_state & CONTROL_LEFT)
		{
			if (char.state != char.state.TEKICK)
				char.flags |= char.flag.FACING_LEFT
			
			vx -= acceleration
			if (vx <= -maxSpeed)
			{
				vx += acceleration
				vx = min(vx, -maxSpeed)
			}
		}
		if (input_state & CONTROL_RIGHT)
		{
			if (char.state != char.state.TEKICK)
				char.flags &= ~char.flag.FACING_LEFT
			
			vx += acceleration
			if (vx >= maxSpeed)
			{
				vx -= acceleration
				vx = max(vx, maxSpeed)
			}
		}

		// Center camera y-offset again
		centerCameraYOffset()

		// Air drag
		if (char.velocity.y < 0 && char.velocity.y >= -0x400)  // Not when falling or going up too fast
		{
			s16 drag = vx >> 5		// Do not divide here, as it rounds differently for negative numbers
			if (drag != 0)
			{
				vx -= drag
				if (drag > 0)
					vx = max(vx, 0)
				else
					vx = min(vx, 0)
			}
		}

		char.velocity.x = vx
	}
	else
	{
		base.Character.UpdateControlInAir()
	}
}

function void Character.DoTEKick()
{
	if (char.state != char.state.TEKICK && char.control_flags == 0 && char.state != char.state.ROLLING)
	{
		char.state = char.state.former
		char.double_jump_state = 1
		char.state = char.state.TEKICK
		char.animation.sprite = 1
		playSound(SFX_INSTASHIELD)
		
		char.flags2d = 0
		
		if ((char.flags & char.flag.IN_AIR) == 0)
		{
			char.flags |= char.flag.IN_AIR
			char.velocity.y -= 0x200
		}
	}
}

function bool Character.CheckTEKickOverLap(u16 px, u16 py, u16 sx, u16 sy)
{
	s16 y_offset = ((char.render_flags & render_flag.FLIP_Y) ? -16 : -8)

	u16 kickbox_pos_x = D2.u16 + ((char.render_flags & render_flag.FLIP_X) ? -12 : 12)
	u16 kickbox_pos_y = objA0.position.y.u16 + y_offset
	u16 kickbox_size_x = 16
	u16 kickbox_size_y = 24
	
	//if (char.state == char.state.TEKICK)
		//debugDrawRect(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, 0x800000ff)
	
	bool kick_overlap = checkBoxOverlap(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, px, py, sx, sy) && char.state == char.state.TEKICK
	//debugLog(kick_overlap)
	
	return kick_overlap
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (char.character == CHARACTER_SONIC)
	{
		SonicUpdateRingCollection()
		UpdateShieldDeflecting()

		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects()
	}
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
	if (char.character == CHARACTER_SONIC)
	{
	#if STANDALONE
		// Bounding box of player
		if (DEBUG_DYNAMIC_COLLISIONS)
			debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
	#endif

		u16 numObjects = global.dynamic_objects.size		// Actually it's twice the number of dynamic objects
		A4 = addressof(global.dynamic_objects.size) + 2		// Resulting address: 0xffffe382
		while (numObjects != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			// Offset into a list of hitbox sizes (the list looks a bit random)
			u16 offset = objA1.collision_attributes
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
				//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
				//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
				//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
				//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
				//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
				//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
				//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
				//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
				//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
				//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
				//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
				//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
				//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
				//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
				//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
				//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
				//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
				//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
				//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
				//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
				//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
				//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
				//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
				//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
				//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
				//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
				//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
				//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
				//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
				//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
				//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
				//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
				//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
				//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
				//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
				//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
				//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
				//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
				//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
				//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
				//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
				//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
				//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
				//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
				//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
				//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
				//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
				//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
				A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS)
				{
					if ((offset & collision_attributes.flags) == collision.flag.ITEM)
						debugDrawRect(px, py, sx, sy, 0x8000ff00)
					else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
						debugDrawRect(px, py, sx, sy, 0x80ff0000)
					else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
						debugDrawRect(px, py, sx, sy, 0x800000ff)
					else
						debugDrawRect(px, py, sx, sy, 0x80ff00ff)
				}
			#endif

				
				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					// Collision found
					Character.OnCollisionWithDynamicObject()
					return
				}
				else if (Character.CheckTEKickOverLap(px, py, sx, sy))
				{
					Character.OnKickCollisionWithDynamicObject()
					return
				}
			}

			numObjects -= 2
		}
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects_partial()
	}
}

function void Character.OnKickCollisionWithDynamicObject()
{
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		if (u8[A1 + 0x29] != 0)
		{
			char.velocity.x = -char.velocity.x
			char.velocity.y = -char.velocity.y
			char.groundspeed = -char.groundspeed
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}

		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)

			objA1.update_address = addressof(SmallExplosion.BaseUpdate)
			u8[A1 + 0x05] = 0
			if (char.velocity.y < 0)
			{
				char.velocity.y += 0x100
			}
			else if (char.position.y.u16 >= objA1.position.y.u16)
			{
				char.velocity.y -= 0x100
			}
			else
			{
				char.velocity.y = -char.velocity.y
			}
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
			if (timer < 90)
			{
				u8[A1 + 0x05] = 0x04
			}
		}
		else
		{
			// This part seems to be for monitors specifically
			s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y
		#if STANDALONE
			// Calculate if the player is moving up, specifically relative to the monitor
			vy = char.velocity.y - objA1.velocity.y
		#endif
			bool movingUp = (objA1.render_flags & render_flag.FLIP_Y) ? (vy > 0) : (vy < 0)
		#if STANDALONE
			movingUp = (vy < 0)		// Velocity is normalised for inverted gravity anyway, so no need for fancy conditional checks

			// If player and monitor are at different orientations, check if player is moving down instead of up
			if ((objA1.render_flags & render_flag.FLIP_Y) != (char.render_flags & render_flag.FLIP_Y))
			{
				movingUp = !movingUp

				if (char.flags & char.flag.IN_AIR)
					objA1.flags2a &= ~object.flag.P1_PUSHING
			}

			movingUp = (movingUp && (abs(char.position.x.u16 - objA1.position.x.u16) < 0x12 || char.state == char.state.ROLLING))		// only bounce at a certain distance, otherwise push the player away when falling, #contributed by GFX32
		#endif
			if (movingUp)
			{
			#if STANDALONE
				if ((objA1.flags2a & object.flag.P1_PUSHING) && (char.flags & char.flag.IN_AIR))
				{
					// In S3AIR, do not allow S&K's monitor opening from the side
					//  -> This is done to be more consistent with other Sonic games, incl. Sonic 1, 2, CD, Mania and even Sonic 3 alone
					//  -> The first check above tells us if the character is on a side of the monitor
					//  -> The second one makes sure that you can always ground-based roll into a monitor (see e.g. first invincibility in MHZ 1, when spindashing into it from the right)
					return
				}
				else if (Game.getSetting(SETTING_MONITOR_BEHAVIOR) == 0)
				{
					// All you really need for Sonic & Knuckles monitor Behavior. everything else relevant is handled elsewhere
					char.velocity.y = -char.velocity.y
				}
				else
				{
					// Improved code to prevent crushing and allow bouncing on ground, #contributed by GFX32

					// If the player is below the monitor, it should bounce.
					bool isBelow = (char.position.y.u16 > (objA1.position.y.u16 + objA1.hitbox_extends.y))

					if (objA1.render_flags & render_flag.FLIP_Y)
						isBelow = (char.position.y.u16 < (objA1.position.y.u16 - objA1.hitbox_extends.y))

					// Not when spindashing!
					if (char.state == char.state.SPINDASH)
						isBelow = false

					if (isBelow)
					{
						// Hit monitor from below, make it fall
						u8[A1 + 0x3c] = 1

						char.velocity.y = -char.velocity.y
						objA1.velocity.y = -0x180

						// Calculate how far the monitor is inside the player, then separate them; this attempts to prevent crushing collision on subsequent frames.
						s16 dy = (objA1.position.y.u16 + objA1.hitbox_extends.y) - (char.position.y.u16 - char.hitbox_extends.y)

						if (objA1.render_flags & render_flag.FLIP_Y)
							dy = (objA1.position.y.u16 - objA1.hitbox_extends.y) - (char.position.y.u16 + char.hitbox_extends.y)

						// Only push the player when in midair
						if (char.flags & char.flag.IN_AIR)
						{
							dy /= 2
							char.position.y.u16 += dy
						}
						objA1.position.y.u16 -= dy

						if (u8[A1 + 0x3c] == 0)
							u8[A1 + 0x3c] = 4

						return
					}
				}
			#else
				if (objA1.flags2a & char.flag.IN_AIR)
				{
					// This block is a bit broken due to the above check, and falling monitors can crush the player, and is this really what we want?

					if ((objA1.render_flags & render_flag.FLIP_Y) == 0)
					{
						if (char.position.y.u16 - 0x10 < objA1.position.y.u16)
							return
					}
					else
					{
						if (char.position.y.u16 + 0x10 >= objA1.position.y.u16)
							return
					}

					char.velocity.y = -char.velocity.y
					objA1.velocity.y = -0x180
					if (u8[A1 + 0x3c] == 0)
						u8[A1 + 0x3c] = 4

					return
				}
			#endif
			}

			if (A0 != 0xffffb000 && competition_mode.active == 0)
			{
				// Sorry player 2, you can't open monitors in normal game
				return
			}

			bool canOpenMonitor = false
			if (char.state == char.state.ROLLING)
			{
				canOpenMonitor = true
			}
		#if STANDALONE
			else if (char.state == char.state.TEKICK)
			{
				canOpenMonitor = true
			}
			else if (objA1.velocity.y < 0)
			{
				// Make monitors break over the player's head at different orientations. #contributed by Dynamic Lemons
				if ((global.inv_gravity != (objA1.render_flags & render_flag.FLIP_Y) != 0))
					canOpenMonitor = true
			}
		#endif

			if (canOpenMonitor)
			{
				objA1.base_state = 0x04		// Set monitor state to broken
				objA1.monitor.character_address = A0.u16		// RAM address of character
			}
		}
	}
	else if (D1.u8 == collision.flag.THREAT)
	{
		// Harmful object, do nothing
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
	}
}

//# address-hook(0x012172) end(0x012178)
//# address-hook(0x01560c) end(0x01569a)
function void Character.LandingOnGround()
{
	if (char.character == CHARACTER_SONIC && char.state == char.state.TEKICK)
	{
		// sorry nothing
	}
	else
	{
		base.Character.LandingOnGround()
	}
}

function void setSpeedCapProperties(u32 address, bool isSuperActive)
{
	if (char.character == CHARACTER_SONIC)
	{
		// Set new max speed cap etc.:
		//  - u16[address]     = maximum speed			-> e.g. global.move.speedcap
		//  - u16[address + 2] = maximum acceleration	-> e.g. global.move.acceleration
		//  - u16[address + 4] = maximum deceleration	-> e.g. global.move.deceleration

		if (char.flags & char.flag.UNDERWATER)
		{
			// In water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				u16[address] = max(u16[address], 0x600)
				u16[address + 2] = max(u16[address + 2], 0x0c)
				u16[address + 4] = max(u16[address + 4], 0x40)
			}
			else
		#endif
			if (isSuperActive)
			{
				u16[address] = 0x500
				u16[address + 2] = 0x18
				u16[address + 4] = 0x80
			}
			else
			{
				u16[address] = 0x300
				u16[address + 2] = 0x06
				u16[address + 4] = 0x40
			}
		}
		else
		{
			// Out of water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				u16[address] = max(u16[address], 0xf00)
				u16[address + 2] = max(u16[address + 2], 0x18)
				u16[address + 4] = max(u16[address + 4], 0x80)
			}
			else
		#endif
			if (isSuperActive)
			{
				u16[address] = 0xa00
				u16[address + 2] = 0x30
				u16[address + 4] = 0x100
			}
			else
			{
				u16[address] = 0x600
				u16[address + 2] = 0x0c
				u16[address + 4] = 0x80
			}
		}
	}
	else
	{
		base.setSpeedCapProperties(address, isSuperActive)
	}
}

//# translated(0x011bde) end(0x011cf0)
//# translated(0x011d16) end(0x011da4)
//# translated(0x0151fc) end(0x01530c)
//# translated(0x015332) end(0x0153c0)
function bool Character.UpdateSpindash()
{
	if (char.character == CHARACTER_SONIC)
		return false
	else
		return base.Character.UpdateSpindash()
}

function void Character.updateUprightOnGround()
{
	if (char.character == CHARACTER_SONIC)
	{
		if (Character.UpdateSpindash())
			return

	#if STANDALONE
		if (Game.getSetting(SETTING_SUPER_PEELOUT))
		{
			if (Character.updateSuperPeelout())
				return
		}
	#endif

		if (Character.CheckStartJump())
			return

		Character.UpdateUprightSlopeEffect()
		Character.updateUprightOnGroundInner()

		Character.sharedUpdateOnGround()
	}
	else
	{
		base.Character.updateUprightOnGround()
	}
}



//# address-hook(0x018cb6) end(0x018d68)
function void fn018cb6()
{
	A1 = 0xffff0000 + objA0.dustcloud.character_address
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		A2 = 0xffff0000 + objA0.dustcloud.character_address
		D1 = 0x10
		
		bool isRunning = (u8[A2 + 0x20] == char.state.RUNNING) && (abs(s16[A2 + 0x1c]) >= 0x600) && ((u8[A2 + 0x26] < 0x40) || (u8[A2 + 0x26] > 0xc0)) && ((u8[A2 + 0x2a] & char.flag.IN_AIR) == 0)
		if (u8[A2 + 0x20] != char.state.BRAKING && !isRunning)
		{
				objA0.base_state = 0x02
				u8[A0 + 0x36] = 0
				return
		}

		--u8[A0 + 0x36]
		if (s8[A0 + 0x36] < 0)
		{
			u8[A0 + 0x36] = 3
			if ((u8[A2 + 0x2a] & char.flag.UNDERWATER) == 0)
			{
				if (allocDynamicObjectStd())
				{
					// Spawn skidding dust
					objA1.update_address = objA0.update_address
					objA1.position.x.u16 = u16[A2 + 0x10]
					objA1.position.y.u16 = u16[A2 + 0x14]
					if (objA0.flags38 != 0)
					{
						D1.u16 -= 4
					}
					if (global.inv_gravity)
						D1.s16 = -D1.s16

					objA1.position.y.u16 += D1.u16
					objA1.render_flags = objA0.render_flags
					u8[A1 + 0x05] += 2
					objA1.box_size.x = 4
					objA1.sprite_priority = 0x80
					objA1.sprite_attributes = (objA0.sprite_attributes & ~sprite_attribute.PRIORITY) | (u16[A2 + 0x0a] & sprite_attribute.PRIORITY)
					objA1.mapping_offset = objA0.mapping_offset
					u8[A1 + 0x20] = 3
					u8[A1 + 0x2a] = 0
					objA1.dustcloud.character_address = objA0.dustcloud.character_address
				}
			}
		}

		fn018d6a()
	}
	else
	{
		base.fn018cb6()
	}
}

function void updateCharacterControlOnGround()
{
	if (char.character == CHARACTER_SONIC)
	{
		u8 input_state     = control.player1.state
		bool isSuperActive = super.active

		D6.u16 = u16[A4] << 1
		D5.u16 = u16[A4 + 2] >> 1
		if (isSuperActive)
		{
			D5.u16 = 6
		}

		if ((char.spindash & 0x80) == 0 && (char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
		{
			if (char.hlock_countdown == 0)
			{
				u16 acceleration = 0x20

				if (input_state & CONTROL_LEFT)
				{
					if (char.groundspeed > 0)
					{
						char.groundspeed -= acceleration
						if (char.groundspeed < 0)
							char.groundspeed = -0x80
					}
					else
					{
						char.flags |= char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}

				if (input_state & CONTROL_RIGHT)
				{
					if (char.groundspeed < 0)
					{
						char.groundspeed += acceleration
						if (char.groundspeed >= 0)
							char.groundspeed = 0x80
					}
					else
					{
						char.flags &= ~char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}
			}

			if (char.groundspeed != 0)
			{
				if (char.groundspeed > 0)
					char.groundspeed = max(char.groundspeed - D5.s16, 0)
				else
					char.groundspeed = min(char.groundspeed + D5.s16, 0)
			}

			if (abs(char.groundspeed) < 0x80)
			{
				if (char.spindash == 0)
				{
					// Stop rolling
					char.flags &= ~char.flag.ROLLING

					s16 dy = s16(char.hitbox_extends.y) - s16(char.hitbox.default.y)
					char.position.y.u16 += (global.inv_gravity) ? -dy : dy

					char.hitbox_extends.x = char.hitbox.default.x
					char.hitbox_extends.y = char.hitbox.default.y
					char.state = char.state.STANDING
				}
				else
				{
					char.groundspeed = (char.flags & char.flag.FACING_LEFT) ? -0x400 : 0x400
				}
			}
		}

		centerCameraYOffset()

		char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
		char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

		char.velocity.x = clamp(char.velocity.x, -0x1000, 0x1000)

		Character.UpdateControlOnGroundShared()
	}
	else
	{
		base.updateCharacterControlOnGround()
	}
}

//# address-hook(0x012232) end(0x0122b8)
function void SonicLandingBubbleBounce()
{
	if (char.character == CHARACTER_SONIC)
	{
		// sorry nothing
	}
	else
	{
		base.SonicLandingBubbleBounce()
	}
}