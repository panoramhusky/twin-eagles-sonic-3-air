constant u16 TESONIC_SPEEDCAP = 0x580
constant u16 TESONIC_ACCEL = 0x000c
constant u16 TESONIC_DECEL = 0xf0

//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_pressed = control.player1.pressed
		
		//if (Input.buttonPressed(BUTTON_Y))
			//global.game_mode = 0x14
		
		if ((input_pressed & CONTROL_A) == 0 && (input_pressed & CONTROL_C) == 0)
			return false
			
		if (char.state == char.state.TEFUCKINGDIED)
			return false

		D0 = char.rotation
		if (global.inv_gravity)
		{
			D0.s8 = -D0.s8
		}
		else
		{
			D0.s8 += 0x80
		}

		pushA456()
		fn00f72e()
		popA456()

		if (D1.s16 < 6)
			return false

		// Get jump acceleration depending on character
		u16 acceleration
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x380
		}
		else if (super.active)
		{
			acceleration = 0x800
		}
		else
		{
			acceleration = 0x680
		}

		u8 angle = char.rotation - 0x40
		s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
		s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

		char.velocity.x += accel_x
		char.velocity.y += accel_y

		char.flags |= char.flag.IN_AIR
		char.flags &= ~char.flag.PUSHING

		char.jumping = 1
		char.on_convex_surface = 0

		Audio.playAudio("te_jump")

		char.hitbox_extends.x = char.hitbox.default.x
		char.hitbox_extends.y = char.hitbox.default.y
		char.flags &= ~char.flag.ROLLING
		char.state = char.state.TEJUMP

		s8 dy = s8(char.hitbox_extends.y) - s8(char.hitbox.default.y)
		char.position.y.u16 += global.inv_gravity ? dy : -dy

	#if STANDALONE
		// Glitch fix for Knuckles being unable to jump off underwater objects
		//  -> Move him up a single pixel up so he won't stick to objects
		// TODO: Does not work for the HCZ snake platforms
		if (acceleration <= 0x300 && (char.flags & char.flag.ON_OBJECT))
		{
			--char.position.y.u16
		}
	#endif
		return true
	}
	else
	{
		return base.Character.CheckStartJump()
	}
}

function void Character.updateJumpMoves()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_state     = control.player1.state
		u8 input_pressed   = control.player1.pressed
		bool isSuperActive = super.active

		if (char.jumping)
		{
			// Limit velocity.y
			s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
			if (char.velocity.y < max_vy)
			{
				// Limit vertical velocity while not pressing any jump button
				//  -> This is important to support low jumps by just tapping the button briefly
				if ((input_state & CONTROL_ABC) == 0)
				{
					char.velocity.y = max_vy
				}
			}
			else
			{
				if (char.double_jump_state == 0)
				{
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}

					// Check if pressed jump again in mid-air
					if (input_pressed & CONTROL_B)
					{
						// Check for other things to do instead of the usual reaction to jump button pressed
						if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
						{
							SonicPressedJumpInMidAir()
						}
					}
				}
			}
		}
		else
		{
			if (char.spindash == 0)
			{
				char.velocity.y = max(char.velocity.y, -0x0fc0)
			}
		}
	}
	else
	{
		base.Character.updateJumpMoves()
	}
}

function void SonicPressedJumpInMidAir()
{
	if (TESonic.isTESonic(A0))
	{
	}
	else
	{
		base.SonicPressedJumpInMidAir()
	}
}

function void Character.updateUprightOnGroundInner()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state != char.state.TEKICK && char.state != char.state.TEFUCKINGDIED)
		{
			base.Character.updateUprightOnGroundInner()
		}
		else
		{
			if (char.state == char.state.TEFUCKINGDIED)
			{
				s16 speed = ((char.rotation > 0x20) ? 0x40 : 0xa0)
				if (char.groundspeed > 0)
					char.groundspeed = max(char.groundspeed - speed, 0)
				else
					char.groundspeed = min(char.groundspeed + speed, 0)
				
				
				char.flags &= ~char.flag.IN_AIR
			}
		
			u8 input_state     = (char.character == CHARACTER_TAILS) ? control.tails.state : control.player1.state
			bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails  : super.active

			// These are in order:
			//  - maximum speed
			//  - maximum acceleration
			//  - maximum deceleration
			D6.u16 = u16[A4]
			D5.u16 = u16[A4 + 2]
			D4.u16 = u16[A4 + 4]

			if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
			{
				// Camera move state:
				//   0 = no input up/down
				//   1 = up/down pressed, but still in delay
				//   2 = up/down pressed, actual movement (limit may be reached)
				u8 cameraMoveState = 0

				if (char.hlock_countdown == 0)
				{
					// Standing upright?
					D0.u8 = (char.rotation + 0x20) & 0xc0
					if (D0.u8 == 0 && char.groundspeed == 0)
					{
						char.flags &= ~char.flag.PUSHING

						checkForBalancing()
					}
				}

			}

			char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
			char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

			Character.UpdateControlOnGroundShared()
			
		}
	
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_B)
		{
			Character.DoTEKick()
		}
	}
	else
	{
		base.Character.updateUprightOnGroundInner()
	}
}

//# address-hook(0x01ab6c) end(0x01ab92)
function void Character.UpdateMovement()
{
	if (TESonic.isTESonic(A0))
	{
		if (super.active && char.state == char.state.TEAIRSLASH && char.spindash_charge > 0)
		{
			if ((char.spindash_charge % 5) == 0)
				playSound(0x48)
		
			UpdateMovementStraightSimple()
			
			return
		}
	}
	
	base.Character.UpdateMovement()
}

//# address-hook(0x011036) end(0x01105e)
function void Character.UpdateSonicRollingInAir()
{
	base.Character.UpdateSonicRollingInAir()

	// s3k jank moment
	if (TESonic.isTESonic(A0))
	{
		if (super.active && char.state == char.state.TEAIRSLASH && char.spindash_charge > 0)
		{
			if (char.flags & char.flag.UNDERWATER)
			{
				// Gravity
				char.velocity.y += 0x28
			}
		}
	}

}

//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state == char.state.TEFUCKINGDIED)
			return
	
		if (super.active && char.state == char.state.TEAIRSLASH && char.spindash_charge > 0)
		{
			--char.spindash_charge
			// Center camera y-offset again
			centerCameraYOffset()
			
			bool isHyper = (super.active == 0xff)
			u16 velocity = (isHyper ? 0xc00 : 0xa00)
			
			bool validSpeed = (abs(char.velocity.x) == velocity || abs(char.velocity.y) == velocity)
			
			if (!validSpeed)
				char.spindash_charge = 0
			
			if (char.spindash_charge == 0)
			{
				char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
				
				char.state = char.state.ROLLING
				char.groundspeed = 0x800
				char.rotation = 0
				
				char.jumping = 0
				char.hitbox_extends.x = char.hitbox.x.ROLLING
				char.hitbox_extends.y = char.hitbox.y.ROLLING
			}
			
			return
		}
	
		u8 input_state = control.player1.state
		s16 vx = char.velocity.x

		s16 maxSpeed = s16[A4]
		s16 acceleration = s16[A4 + 2] * 2

		if (input_state & CONTROL_LEFT)
		{
			if (char.state != char.state.TEKICK)
				char.flags |= char.flag.FACING_LEFT
			
			vx -= acceleration
			if (vx <= -maxSpeed)
			{
				vx += acceleration
				vx = min(vx, -maxSpeed)
			}
		}
		if (input_state & CONTROL_RIGHT)
		{
			if (char.state != char.state.TEKICK)
				char.flags &= ~char.flag.FACING_LEFT
			
			vx += acceleration
			if (vx >= maxSpeed)
			{
				vx -= acceleration
				vx = max(vx, maxSpeed)
			}
		}

		// Center camera y-offset again
		centerCameraYOffset()

		// Air drag
		if (char.velocity.y < 0 && char.velocity.y >= -0x400)  // Not when falling or going up too fast
		{
			s16 drag = vx >> 5		// Do not divide here, as it rounds differently for negative numbers
			if (drag != 0)
			{
				vx -= drag
				if (drag > 0)
					vx = max(vx, 0)
				else
					vx = min(vx, 0)
			}
		}

		char.velocity.x = vx
		
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_B)
		{
			Character.DoTEKick()
		}
	}
	else
	{
		base.Character.UpdateControlInAir()
	}
}


function void Character.DoTEKick()
{
	constant array<u8> STATES =
	{
		0x00, // char.state.RUNNING
		0x01, // char.state.RUNNING2
		0x04, // char.state.PUSHING
		0x05, // char.state.STANDING
		0x07, // char.state.LOOKING_UP
		0x08, // char.state.COWERING
		0x0d, // char.state.BRAKING
		0x10, // char.state.STRAIGHTJUMP
		0x40, // char.state.TEJUMP
	}

	bool validState = false
	
	for (u8 i = 0; i < 9; ++i)
	{
		if (char.state == STATES[i])
		{
			validState = true
		}
	}
	
	// check with objects the player cannot kick on
	A1 = 0xffff0000 + char.object_standing_on
	//debugLog(A1)
	if (char.flags & char.flag.ON_OBJECT)
	{
		// cnz barber pole
		if (objA1.update_address == 0x033376)
			validState = false
			
		// lbz cylinder
		if (objA1.update_address == 0x02c3ca)
			validState = false
	}
	
	// check if in corkscrew state
	if (char.rotation.x.count != 0)
		validState = false
	
	if (char.state != char.state.TEKICK && char.control_flags == 0 && validState)
	{
		char.double_jump_state = 1
		char.flags2d = 0
		
		if (!super.active)
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
					// kick
					char.flags |= char.flag.IN_AIR
					
					if (char.flags & char.flag.ON_OBJECT)
					{
						char.flags &= ~char.flag.ON_OBJECT
						objA0.position.y.u16 -= 1
					}
					
					u16 acceleration = ((char.flags & char.flag.UNDERWATER) ? 0x080 : 0x200)
					
					u8 angle = char.rotation - 0x40
					s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
					s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

					char.velocity.x += accel_x
					char.velocity.y += accel_y
			}
		}
		else
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
				// sword slash	
				if (abs(char.velocity.x) < 0x800)
				{
					char.groundspeed = ((char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800)
					char.velocity.x = char.groundspeed
				}
			}
		}
		
		char.state = char.state.former
		char.rotation = 0
		
		if (!super.active)
		{
			char.state = char.state.TEKICK
			char.animation.sprite = 1
			Audio.playAudio("te_kick")
		}
		else
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
				char.state = char.state.TEKICK
				char.animation.sprite = 1
				playSound(SFX_SPINDASH_RELEASE)
			}
			else
			{
				TESonic.DoTEAirSlash()
			}
		}
	}
}

function void TESonic.DoTEAirSlash()
{
	char.jumping = 0
	char.double_jump_state = 2	// Always set this flag; needed for Drop Dash
	bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
	u8 input = control.player1.state & CONTROL_DPAD		// Only directions
	
	char.state = char.state.TEAIRSLASH
	char.spindash_charge = 30

	if (isHyperSonic)	// Super Sonic's dash does not cause a screen flash
	{
		Character.ClearEnemiesOnScreen()
	}

	ClearPositionBackup()

	char.double_jump_state = 1
#if STANDALONE
	if (!isHyperSonic)
		u8[0xffffcbc0 + 0x20] = 1
	else
#endif
		u8[0xffffcd7c + 0x20] = 1

	playSound(SFX_SPINDASH_RELEASE)

	if (input != 0 && input < 0x0b)		// Not left and right at the same time
	{
		// Perform Jet Dash
		
		if (input & CONTROL_LEFT)
			char.velocity.x = -0x800
		else if (input & CONTROL_RIGHT)
			char.velocity.x = 0x800
		else if (((input & CONTROL_LEFT) == 0) && ((input & CONTROL_RIGHT) == 0))
			char.velocity.x = 0
			
			if (input & CONTROL_UP)
			char.velocity.y = -0x800
		else if (input & CONTROL_DOWN)
			char.velocity.y = 0x800
		else if (((input & CONTROL_UP) == 0) && ((input & CONTROL_DOWN) == 0))
			char.velocity.y = 0

		char.velocity.x = ((char.velocity.x * 3) / 2)
		char.velocity.y = ((char.velocity.y * 3) / 2)
	}
	else
	{
		char.velocity.x = (char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800
		char.velocity.x = ((char.velocity.x * 3) / 2)
		char.velocity.y = 0
	}

#if STANDALONE
	if (!isHyperSonic)
	{
		// Reduce dash speed for Super Sonic
		char.velocity.x = (char.velocity.x > 0) ? (char.velocity.x - 0x200) : (char.velocity.x < 0) ? (char.velocity.x + 0x200) : 0
		char.velocity.y = (char.velocity.y > 0) ? (char.velocity.y - 0x200) : (char.velocity.y < 0) ? (char.velocity.y + 0x200) : 0
	}
#endif

	char.groundspeed = objA0.velocity.x
}

function bool Character.CheckTEKickOverLap(u16 px, u16 py, u16 sx, u16 sy)
{
	s16 y_offset = ((char.render_flags & render_flag.FLIP_Y) ? -16 : -8)

	u16 kickbox_pos_x = D2.u16 + ((char.render_flags & render_flag.FLIP_X) ? -12 : 12)
	u16 kickbox_pos_y = objA0.position.y.u16 + y_offset
	u16 kickbox_size_x = ((!super.active) ? 16 : 48)
	u16 kickbox_size_y = 24
	
	//if (char.state == char.state.TEKICK)
		//debugDrawRect(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, 0x800000ff)
	
	bool kick_overlap = checkBoxOverlap(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, px, py, sx, sy) && char.state == char.state.TEKICK
	//debugLog(kick_overlap)
	
	return kick_overlap
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (TESonic.isTESonic(A0))
	{
		SonicUpdateRingCollection()
		UpdateShieldDeflecting()

		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects()
	}
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
	if (TESonic.isTESonic(A0))
	{
	#if STANDALONE
		// Bounding box of player
		if (DEBUG_DYNAMIC_COLLISIONS)
			debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
	#endif

		u16 numObjects = global.dynamic_objects.size		// Actually it's twice the number of dynamic objects
		A4 = addressof(global.dynamic_objects.size) + 2		// Resulting address: 0xffffe382
		while (numObjects != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			// Offset into a list of hitbox sizes (the list looks a bit random)
			u16 offset = objA1.collision_attributes
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
				//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
				//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
				//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
				//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
				//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
				//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
				//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
				//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
				//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
				//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
				//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
				//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
				//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
				//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
				//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
				//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
				//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
				//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
				//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
				//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
				//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
				//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
				//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
				//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
				//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
				//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
				//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
				//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
				//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
				//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
				//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
				//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
				//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
				//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
				//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
				//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
				//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
				//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
				//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
				//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
				//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
				//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
				//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
				//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
				//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
				//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
				//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
				//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
				A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS)
				{
					if ((offset & collision_attributes.flags) == collision.flag.ITEM)
						debugDrawRect(px, py, sx, sy, 0x8000ff00)
					else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
						debugDrawRect(px, py, sx, sy, 0x80ff0000)
					else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
						debugDrawRect(px, py, sx, sy, 0x800000ff)
					else
						debugDrawRect(px, py, sx, sy, 0x80ff00ff)
				}
			#endif

				
				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					// Collision found
					Character.OnCollisionWithDynamicObject()
					return
				}
				else if (Character.CheckTEKickOverLap(px, py, sx, sy))
				{
					Character.OnKickCollisionWithDynamicObject()
					return
				}
			}

			numObjects -= 2
		}
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects_partial()
	}
}

//# address-hook(0x00ffd4) end(0x010214)
function void Character.OnCollisionWithDynamicObject()
{
	if (TESonic.isTESonic(A0))
	{
		// Example values for objA1.collision_attributes:
		//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
		//  - 0x0f		 = Boss enemy
		//  - 0x18		 = Extended arm of DEZ Chainspike
		//  - 0x23		 = AIZ Bloominator
		//  - 0x46		 = Monitor
		//  - 0x47		 = Dynamic ring
		//  - 0x87		 = Extended arm of SOZ Skorp
		//  - 0x8b, 0x9c = Flames, damaging parts of enemies
		//  - 0x8f		 = Wrecking ball
		//  - 0x98, 0x9b = Projectile
		//  - 0xd8		 = Thrown mushroom, stars over starpost

		D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
		if (D1.u8 == 0)
		{
			// Collision is an enemy, i.e. is harmful, but can be attacked
			bool attacking = false
			if (char.bonus_effect & char.bonus.INVINCIBLE || char.state == char.state.ROLLING || char.state == char.state.SPINDASH)
			{
				attacking = true
			}

			if (!attacking)
			{
				bool isThreat = false
				if (char.double_jump_state == 0 || (char.flags & char.flag.UNDERWATER))
				{
					// No real special conditions for Sonic besides the drop dash
					isThreat = true
				}

				if (isThreat)
				{
					Character.OnThreatCollision()
					return
				}
			}

			if (u8[A1 + 0x29] != 0)
			{
				char.velocity.x = -char.velocity.x
				char.velocity.y = -char.velocity.y
				char.groundspeed = -char.groundspeed
				
				if (char.state == char.state.TEAIRSLASH)
					char.spindash_charge = 0
				
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
			}
			else
			{
				if (u8[A1 + 0x2a] & 0x04)
				{
					A2 = 0xffff0000 + u16[A1 + 0x3c]
					u8[A2] &= ~(1 << u8[A1 + 0x3b])
				}

				u8[A1 + 0x2a] |= 0x80

				// Grant bonus points
				Enemy.addScore(A1, 0x010216)

				objA1.update_address = addressof(SmallExplosion.BaseUpdate)
				u8[A1 + 0x05] = 0
				if (char.velocity.y < 0)
				{
					char.velocity.y += 0x100
				}
				else if (char.position.y.u16 >= objA1.position.y.u16)
				{
					char.velocity.y -= 0x100
				}
				else
				{
					char.velocity.y = -char.velocity.y
				}
			}
		}
		else if (D1.u8 == collision.flag.ITEM)
		{
			D0.u8 = (objA1.collision_attributes & collision_attributes.size)
			if (D0.u8 != collision.size.16x16)
			{
				// Collect ring, but only after 30 invulnerability frames
				//  -> Remember that the "char.invuln.countdown" timer starts at 120
				u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
				if (timer < 90)
				{
					u8[A1 + 0x05] = 0x04
				}
			}
			else
			{
				// This part seems to be for monitors specifically
				s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y

				if (A0 != 0xffffb000 && competition_mode.active == 0)
				{
					// Sorry player 2, you can't open monitors in normal game
					return
				}

				bool canOpenMonitor = true

				if (canOpenMonitor)
				{
					objA1.base_state = 0x04		// Set monitor state to broken
					objA1.monitor.character_address = A0.u16		// RAM address of character
				}
			}
		}
		else if (D1.u8 == collision.flag.THREAT)
		{
			// Harmful object
			Character.OnThreatCollision()
		}
		else  // D1.u8 == collision.flag.SPECIAL
		{
			// Other interactable object
			fn0103ba()
		}
	}
	else
	{
		base.Character.OnCollisionWithDynamicObject()
	}
}

function void Character.OnKickCollisionWithDynamicObject()
{
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		if (u8[A1 + 0x29] != 0)
		{
			char.velocity.x = -char.velocity.x
			char.velocity.y = -char.velocity.y
			char.groundspeed = -char.groundspeed
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}

		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)

			objA1.update_address = addressof(SmallExplosion.BaseUpdate)
			u8[A1 + 0x05] = 0
			if (char.velocity.y < 0)
			{
				char.velocity.y += 0x100
			}
			else if (char.position.y.u16 >= objA1.position.y.u16)
			{
				char.velocity.y -= 0x100
			}
			else
			{
				char.velocity.y = -char.velocity.y
			}
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
			if (timer < 90)
			{
				u8[A1 + 0x05] = 0x04
			}
		}
		else
		{
			// This part seems to be for monitors specifically
			s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y

			if (A0 != 0xffffb000 && competition_mode.active == 0)
			{
				// Sorry player 2, you can't open monitors in normal game
				return
			}

			bool canOpenMonitor = true

			if (canOpenMonitor)
			{
				objA1.base_state = 0x04		// Set monitor state to broken
				objA1.monitor.character_address = A0.u16		// RAM address of character
			}
		}
	}
	else if (D1.u8 == collision.flag.THREAT)
	{
		// Harmful object, do nothing
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
	}
}

//# address-hook(0x012172) end(0x012178)
//# address-hook(0x01560c) end(0x01569a)
function void Character.LandingOnGround()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state == char.state.TEKICK)
		{
			if (char.rotation > 0x20 && char.rotation < 0xe0 && (char.flags & char.flag.ROLLING) == 0)
			{
				char.flags &= ~(char.flag.IN_AIR | char.flag.PUSHING | char.flag.CONTROL_LOCK)
				char.state = char.state.RUNNING
				char.animation.timer = 0
				char.rotation.x = 0
			}
			else
			{	
				Character.LandingOnGroundStandUp()
				Character.LandingOnGroundResetState()
			}
		}
		else if (char.state == char.state.TEFUCKINGDIED)
		{
			s16 speed = ((char.rotation > 0x20) ? 0x40 : 0xa0)
			if (char.groundspeed > 0)
				char.groundspeed = max(char.groundspeed - speed, 0)
			else
				char.groundspeed = min(char.groundspeed + speed, 0)
			
			char.flags &= ~char.flag.IN_AIR
		}
		else
		{
			base.Character.LandingOnGround()
		}
	}
	else
	{
		base.Character.LandingOnGround()
	}
}


function void setSpeedCapProperties(u32 address, bool isSuperActive)
{
	if (TESonic.isTESonic(A0))
	{
		// Set new max speed cap etc.:
		//  - u16[address]     = maximum speed			-> e.g. global.move.speedcap
		//  - u16[address + 2] = maximum acceleration	-> e.g. global.move.acceleration
		//  - u16[address + 4] = maximum deceleration	-> e.g. global.move.deceleration

		if (char.flags & char.flag.UNDERWATER)
		{
			// In water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				//debugLog("speed up in water")
				u16[address] = Math.roundToInt(TESONIC_SPEEDCAP * 1.0)
				u16[address + 2] = Math.roundToInt(TESONIC_ACCEL * 1.0)
				u16[address + 4] = Math.roundToInt(TESONIC_DECEL * 0.5)
			}
			else
		#endif
			if (isSuperActive)
			{
				//debugLog("super in water")
				u16[address] = Math.roundToInt(TESONIC_SPEEDCAP * 0.833333333)
				u16[address + 2] = Math.roundToInt(TESONIC_ACCEL * 2.0)
				u16[address + 4] = Math.roundToInt(TESONIC_DECEL * 1.0)
			}
			else
			{
				//debugLog("in water")
				u16[address] = Math.roundToInt(TESONIC_SPEEDCAP * 0.5) 
				u16[address + 2] = Math.roundToInt(TESONIC_ACCEL * 0.5) 
				u16[address + 4] = Math.roundToInt(TESONIC_DECEL * 0.5) 
			}
		}
		else
		{
			// Out of water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				//debugLog("speed up")
				u16[address] = Math.roundToInt(TESONIC_SPEEDCAP * 2)
				u16[address + 2] = Math.roundToInt(TESONIC_ACCEL * 2.0)
				u16[address + 4] = Math.roundToInt(TESONIC_DECEL * 1.0)
			}
			else
		#endif
			if (isSuperActive)
			{
				//debugLog("super")
				u16[address] = Math.roundToInt(TESONIC_SPEEDCAP * 1.66666667)
				u16[address + 2] = Math.roundToInt(TESONIC_ACCEL * 4.0)
				u16[address + 4] = Math.roundToInt(TESONIC_DECEL * 2.0)
			}
			else
			{
				//debugLog("normal")
				u16[address] = TESONIC_SPEEDCAP
				u16[address + 2] = TESONIC_ACCEL
				u16[address + 4] = TESONIC_DECEL
			}
		}
	}
	else
	{
		base.setSpeedCapProperties(address, isSuperActive)
	}
}

//# translated(0x011bde) end(0x011cf0)
//# translated(0x011d16) end(0x011da4)
//# translated(0x0151fc) end(0x01530c)
//# translated(0x015332) end(0x0153c0)
function bool Character.UpdateSpindash()
{
	if (TESonic.isTESonic(A0))
		return false
	else
		return base.Character.UpdateSpindash()
}


function void Character.updateUprightOnGround()
{
	// update on solid ground
	if (TESonic.isTESonic(A0))
	{
		if (Character.UpdateSpindash())
			return

		if (Character.updateSuperPeelout())
			return

		if (Character.CheckStartJump())
			return

		Character.UpdateUprightSlopeEffect()
		Character.updateUprightOnGroundInner()
		Character.CheckForStartRolling()

		Character.sharedUpdateOnGround()
	}
	else
	{
		base.Character.updateUprightOnGround()
	}
}

//# address-hook(0x01174a) end(0x0117d8)
//# address-hook(0x014f74) end(0x015000)
function void Character.CheckForStartRolling()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state == char.state.TEFUCKINGDIED)
			return
		
		u8 input_state = control.player1.state

		if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
		{
			if ((input_state & (CONTROL_LEFT | CONTROL_RIGHT)) == 0)	// No left or right pressed
			{
				if (input_state & CONTROL_DOWN)
				{
					if ((char.flags & char.flag.ON_OBJECT) == 0 && abs(char.groundspeed) < 0x100)
					{
						char.state = char.state.COWERING
					#if STANDALONE
						// Also slow down a little
						if (char.groundspeed <= -4)
							char.groundspeed += 4
						else if (char.groundspeed >= 4)
							char.groundspeed -= 4
					#endif
					}
				}
				else
				{
					// Stop crouching
					if (char.state == char.state.COWERING)
						char.state = char.state.RUNNING

				#if STANDALONE
					// Allow for starting the Super Peel-Out even if still moving slowly, just like handling for the spindash
					//  (this logic here is active even if the Peel-Out is not enabled)
					//   (this is also literally a NECESSITY for TE Sonic, especially in areas like the HCZ wall chase)
					if ((input_state & CONTROL_UP) && abs(char.groundspeed) < 0x100 && (char.flags & char.flag.ON_OBJECT) == 0)
					{
						char.state = char.state.LOOKING_UP
						if (char.groundspeed <= -4)
							char.groundspeed += 4
						else if (char.groundspeed >= 4)
							char.groundspeed -= 4
					}
				#endif
				}
			}
		}
	}
	else
	{
		base.Character.CheckForStartRolling()
	}
}

function bool Character.updateSuperPeelout()
{
	// update on solid ground
	if (TESonic.isTESonic(A0))
	{
		u8 input_state   = control.player1.state
		u8 input_pressed = control.player1.pressed

		if (char.spindash == 0)
		{
			bool canStartPeelout = (char.state == char.state.LOOKING_UP) && (input_pressed & CONTROL_ABC) && (player1.control_override == 0)	// Last check is needed in cutscenes (e.g. end of MHZ 2)
			if (!canStartPeelout)
			{
				// Nothing to see here
				return false
			}

			char.state = char.state.RUNNING
			char.spindash = 0x80
			char.spindash_charge = 0
			playSound(0x5a)
		}
		else if (char.spindash == 0x80)
		{
			A4 = addressof(global.move.speedcap)	// Address: 0xfffff760 = Base address of speed caps & acceleration/deceleration
		
			if (input_state & CONTROL_UP || char.spindash_charge < 0x480)
			{
				// Charge up
				char.spindash_charge = clamp(char.spindash_charge + u16[A4 + 2] + 10, 0, 0x480)
				if (char.flags & char.flag.UNDERWATER)
				{
					char.groundspeed = 0x480 + ((super.active) ? (char.spindash_charge) : (char.spindash_charge * 3/4))
				}
				else
				{
					char.groundspeed = 0x480 + ((super.active) ? (char.spindash_charge * 3/2) : (char.spindash_charge))
				}

				char.flags &= ~char.flag.PUSHING


			#if STANDALONE
				Input.setControllerRumbleByAddress(A0, 0.0f, 0.25f, 100)
			#endif
			}
			else
			{
				releaseSuperPeelout()
			}

			// Center camera y-offset again
			centerCameraYOffset()
		}

		Character.CheckAgainstMoveBorders()
		Character.UpdateRotationOnGround()
		partialUpdateCharacterOnGround()

		return true
	}
	else
	{
		return base.Character.updateSuperPeelout()
	}
}

function void releaseSuperPeelout()
{
	// Release the Super Peel-Out!
	if (TESonic.isTESonic(A0))
	{
		char.state = char.state.RUNNING
		char.spindash = 0

		D0.u16 = max(char.groundspeed - 0x800, 0) * 2
		D0.u16 = 0x2000 - (D0.u16 & 0x1f00)
		
		if (char.flags & char.flag.FACING_LEFT)
		{
			char.groundspeed = -char.groundspeed
		}

		playSound(SFX_SPINDASH_RELEASE)
		Input.setControllerRumbleByAddress(A0, 0.0f, 1.0f, 150)
	}
	else
	{
		base.releaseSuperPeelout()
	}
}


//# address-hook(0x018b3e) end(0x018b48)
function void fn018b3e()
{
	base.fn018b3e()

	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A2 = A1
		
		// top 10 most hacked in checks ever NUMBER ONNNEEEE
		bool isRunning = (u8[A2 + 0x20] == char.state.RUNNING || u8[A2 + 0x20] == char.state.RUNNING2) && ((u8[A2 + 0x26] < 0x40) || (u8[A2 + 0x26] > 0xc0)) && ((u8[A2 + 0x2a] & char.flag.IN_AIR) == 0) && (u8[A2 + 0x2e] & control_flag.DISABLE_UPDATE) == 0 && abs(s16[A2 + 0x1c]) > 0x80

		if (!isRunning)
			return

		--u8[A0 + 0x38]
		if (s8[A0 + 0x38] < 0)
		{
			u8[A0 + 0x38] = 4
			if ((u8[A2 + 0x2a] & char.flag.UNDERWATER) == 0 && !super.active && u8[A2 + 0x2a] != char.flag.PUSHING)
			{
				if (u8[A2 + 0x2d] != 0)
					return
			
				if (allocDynamicObjectStd())
				{
					// Spawn skidding dust
					objA1.update_address = 0x2302fa
					objA1.render_flags = objA0.render_flags

					u8[A1 + 0x05] += 0x02
					objA1.box_size.x = 0x04
					objA1.sprite_priority = 0x80
					objA1.sprite_attributes = (objA0.sprite_attributes & ~sprite_attribute.PRIORITY) | (u16[A2 + 0x0a] & sprite_attribute.PRIORITY)
					u16[A1 + 0x10] = u16[A2 + 0x10]
					u16[A1 + 0x14] = u16[A2 + 0x14] + 0x0c
					u8[A1 + 0x20] = 0x03
					u8[A1 + 0x2a] = 0
					
					
					
					if (u8[A2 + 0x3d] != 0)
					{
						objA1.velocity.x = (s16[A2 + 0x1c] >> 1)
						objA1.velocity.x *= ((u8[A2 + 0x04] & render_flag.FLIP_X) ? 1 : -1)
					}
				}
			}
		}
	}
}


function void updateCharacterControlOnGround()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_state     = control.player1.state
		bool isSuperActive = super.active

		D6.u16 = u16[A4] << 1
		D5.u16 = u16[A4 + 2] >> 1
		if (isSuperActive)
		{
			D5.u16 = 6
		}

		if ((char.spindash & 0x80) == 0 && (char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
		{
			if (char.hlock_countdown == 0)
			{
				u16 acceleration = 0x20

				if (input_state & CONTROL_LEFT)
				{
					if (char.groundspeed > 0)
					{
						char.groundspeed -= acceleration
						if (char.groundspeed < 0)
							char.groundspeed = -0x80
					}
					else
					{
						char.flags |= char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}

				if (input_state & CONTROL_RIGHT)
				{
					if (char.groundspeed < 0)
					{
						char.groundspeed += acceleration
						if (char.groundspeed >= 0)
							char.groundspeed = 0x80
					}
					else
					{
						char.flags &= ~char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}
			}

			if (char.groundspeed != 0)
			{
				if (char.groundspeed > 0)
					char.groundspeed = max(char.groundspeed - D5.s16, 0)
				else
					char.groundspeed = min(char.groundspeed + D5.s16, 0)
			}

			if (abs(char.groundspeed) < 0x80)
			{
				if (char.spindash == 0)
				{
					// Stop rolling
					char.flags &= ~char.flag.ROLLING

					s16 dy = s16(char.hitbox_extends.y) - s16(char.hitbox.default.y)
					char.position.y.u16 += (global.inv_gravity) ? -dy : dy

					char.hitbox_extends.x = char.hitbox.default.x
					char.hitbox_extends.y = char.hitbox.default.y
					char.state = char.state.STANDING
				}
				else
				{
					char.groundspeed = (char.flags & char.flag.FACING_LEFT) ? -0x400 : 0x400
				}
			}
		}

		centerCameraYOffset()

		char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
		char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

		char.velocity.x = clamp(char.velocity.x, -0x1000, 0x1000)

		Character.UpdateControlOnGroundShared()
	}
	else
	{
		base.updateCharacterControlOnGround()
	}
}

//# address-hook(0x012232) end(0x0122b8)
function void SonicLandingBubbleBounce()
{
	if (TESonic.isTESonic(A0))
	{
		// sorry nothing
	}
	else
	{
		base.SonicLandingBubbleBounce()
	}
}

function void gainExtraLife()
{
	// we need to back up and restore the A1 here otherwise the game shits itself
	u32 A1backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (!Game.getSetting(SETTING_INFINITE_LIVES))
		{
			Audio.playAudio("te_1up")
			lives_counter = min(lives_counter + 1, 99)
			++hud.dirty.lives
		}
	}
	else
	{
		base.gainExtraLife()
	}
	
	A1 = A1backup
}

//# address-hook(0x01036e) end(0x0103b8)
function void Character.Die_internal()
{
	if (TESonic.isTESonic(A0))
	{
		TESonic.health = 0
		Character.Die_noSound()
		Audio.playAudio("te_death")
		D0 = 0xffffffff
	}
	else
	{
		base.Character.Die_internal()
	}
}

//# address-hook(0x010366) end(0x01036c)
function void Character.Die()
{
	if (TESonic.isTESonic(A0))
	{
		if (debug_mode.state == 0)
		{
			TESonic.health = 0
			Character.Die_noSound()
			Audio.playAudio("te_death")
		}
		D0 = 0xffffffff
	}
	else
	{
		base.Character.Die()
	}
}

//# address-hook(0x0125ac) end(0x0125da)
function void Character.UpdateDrownedState.Sonic()
{
	TESonic.health = 0
	base.Character.UpdateDrownedState.Sonic()
}

function bool debugModeRescue()
{
	A1 = 0xffffb000
	// Get character out of damage state and into object placement mode
	if (debug_mode.enabled && (control.pad1.pressed & CONTROL_B) && TESonic.isTESonic(A1))
	{
		debug_mode.state = 1
		player1.control_override = 0
		char.invuln.countdown = 120
		
		if (TESonic.health < 1)
			TESonic.health = 1
		
		return true
	}
	
	return base.debugModeRescue()

}

function bool Character.performSuperTransformation()
{
	if (TESonic.isTESonic(A0))
	{
		u8 possibleSuperForm = 0	// 1 for Super, 2 for Hyper
		// Can go super?
		if (global.super_emeralds >= 7)
		{
			possibleSuperForm = 2
		}
		else if (global.chaos_emeralds >= 7 && global.traded_emeralds == 0)
		{
			possibleSuperForm = 1
		}
		
		bool max_health = (TESonic.health >= 3 && TESonic.maxhealth >= 3)

		

		if (!super.active && ring_counter >= 50 && hud.dirty.timer && char.control_flags == 0 && possibleSuperForm != 0)
		{
			if (!max_health)
			{
				playSound(0xb2)
				return false
			}
		
			Audio.playAudio("te_sonic")
			TESonic.health = 5
			TESonic.maxhealth = 5
		}
	}
	
	return base.Character.performSuperTransformation()
}

function void Character.cancelSuperTransformation()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state == char.state.TEFUCKINGDIED && hud.dirty.timer)
			return
	}
	
	base.Character.cancelSuperTransformation()
}

//# address-hook(0x08160a) end(0x081676)
function void fn08160a()
{
	base.fn08160a()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA0.countdown_value >= 0)
			return
			
		Audio.playAudio("te_sonic")
		TESonic.health = 5
		TESonic.maxhealth = 5
	}
}

function void EntryFunctions.sharedInit()
{
	TESonic.health = 3
		
	TESonic.maxhealth = 3	
	base.EntryFunctions.sharedInit()
}

function void Standalone.onLevelStart()
{
	TESonic.health = 3
	if (TESonic.maxhealth < 3)
		TESonic.maxhealth = 3
	
	base.Standalone.onLevelStart()
}

function void Standalone.onRestartLevel()
{
	TESonic.health = 3
	TESonic.maxhealth = 3
	base.Standalone.onRestartLevel()
}

function void Standalone.onRestartAtCheckpoint()
{
	TESonic.health = 3
	
	if (TESonic.maxhealth > 3 || TESonic.maxhealth == 0)
		TESonic.maxhealth = 3
	
	base.Standalone.onRestartAtCheckpoint()
}

function void Standalone.onLevelFinished()
{
	TESonic.health = 3
	
	base.Standalone.onLevelFinished()
}

function void Standalone.onDeath()
{
	TESonic.health = 3
	TESonic.maxhealth = 3

	base.Standalone.onDeath()
}