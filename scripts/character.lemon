//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_pressed = control.player1.pressed
		if ((input_pressed & CONTROL_A) == 0 && (input_pressed & CONTROL_C) == 0)
			return false

		D0 = char.rotation
		if (global.inv_gravity)
		{
			D0.s8 = -D0.s8
		}
		else
		{
			D0.s8 += 0x80
		}

		pushA456()
		fn00f72e()
		popA456()

		if (D1.s16 < 6)
			return false

		// Get jump acceleration depending on character
		u16 acceleration
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x380
		}
		else if (super.active)
		{
			acceleration = 0x800
		}
		else
		{
			acceleration = 0x680
		}

		u8 angle = char.rotation - 0x40
		s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
		s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

		char.velocity.x += accel_x
		char.velocity.y += accel_y

		char.flags |= char.flag.IN_AIR
		char.flags &= ~char.flag.PUSHING

		char.jumping = 1
		char.on_convex_surface = 0

		Audio.playAudio("te_jump")

		char.hitbox_extends.x = char.hitbox.default.x
		char.hitbox_extends.y = char.hitbox.default.y
		char.flags &= ~char.flag.ROLLING
		char.state = char.state.TEJUMP

		s8 dy = s8(char.hitbox_extends.y) - s8(char.hitbox.default.y)
		char.position.y.u16 += global.inv_gravity ? dy : -dy

	#if STANDALONE
		// Glitch fix for Knuckles being unable to jump off underwater objects
		//  -> Move him up a single pixel up so he won't stick to objects
		// TODO: Does not work for the HCZ snake platforms
		if (acceleration <= 0x300 && (char.flags & char.flag.ON_OBJECT))
		{
			--char.position.y.u16
		}
	#endif
		return true
	}
	else
	{
		return base.Character.CheckStartJump()
	}
}

function void Character.updateJumpMoves()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_state     = control.player1.state
		u8 input_pressed   = control.player1.pressed
		bool isSuperActive = super.active

		if (char.jumping)
		{
			// Limit velocity.y
			s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
			if (char.velocity.y < max_vy)
			{
				// Limit vertical velocity while not pressing any jump button
				//  -> This is important to support low jumps by just tapping the button briefly
				if ((input_state & CONTROL_ABC) == 0)
				{
					char.velocity.y = max_vy
				}
			}
			else
			{
				if (char.double_jump_state == 0)
				{
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}

					// Check if pressed jump again in mid-air
					if (input_pressed & CONTROL_B)
					{
						// Check for other things to do instead of the usual reaction to jump button pressed
						if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
						{
							SonicPressedJumpInMidAir()
						}
					}
				}
			}
		}
		else
		{
			if (char.spindash == 0)
			{
				char.velocity.y = max(char.velocity.y, -0x0fc0)
			}
		}
	}
	else
	{
		base.Character.updateJumpMoves()
	}
}

function void SonicPressedJumpInMidAir()
{
	if (TESonic.isTESonic(A0))
	{
	}
	else
	{
		base.SonicPressedJumpInMidAir()
	}
}

function void Character.updateUprightOnGroundInner()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state != char.state.TEKICK && char.state != char.state.TEFUCKINGDIED)
		{
			base.Character.updateUprightOnGroundInner()
		}
		else
		{
			u8 input_state     = (char.character == CHARACTER_TAILS) ? control.tails.state : control.player1.state
			bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails  : super.active

			// These are in order:
			//  - maximum speed
			//  - maximum acceleration
			//  - maximum deceleration
			D6.u16 = u16[A4]
			D5.u16 = u16[A4 + 2]
			D4.u16 = u16[A4 + 4]

			if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
			{
				// Camera move state:
				//   0 = no input up/down
				//   1 = up/down pressed, but still in delay
				//   2 = up/down pressed, actual movement (limit may be reached)
				u8 cameraMoveState = 0

				if (char.hlock_countdown == 0)
				{
					// Standing upright?
					D0.u8 = (char.rotation + 0x20) & 0xc0
					if (D0.u8 == 0 && char.groundspeed == 0)
					{
						char.flags &= ~char.flag.PUSHING

						checkForBalancing()
					}
				}

			}

			char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
			char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

			Character.UpdateControlOnGroundShared()
			
		}
	
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_B)
		{
			Character.DoTEKick()
		}
	}
	else
	{
		base.Character.updateUprightOnGroundInner()
	}
}

//# address-hook(0x01ab6c) end(0x01ab92)
function void Character.UpdateMovement()
{
	if (TESonic.isTESonic(A0))
	{
		if (super.active && char.state == char.state.TEAIRSLASH && char.spindash_charge > 0)
		{
			UpdateMovementStraightSimple()
			return
		}
	}
	
	base.Character.UpdateMovement()
}

//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if (TESonic.isTESonic(A0))
	{
		if (super.active && char.state == char.state.TEAIRSLASH && char.spindash_charge > 0)
		{
			--char.spindash_charge
			// Center camera y-offset again
			centerCameraYOffset()
			
			if (char.velocity.x == 0 && char.velocity.y == 0)
				char.spindash_charge = 0
			
			if (char.spindash_charge == 0)
			{
				char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
				char.state = char.state.ROLLING
				char.jumping = 0
				char.hitbox_extends.x = char.hitbox.x.ROLLING
				char.hitbox_extends.y = char.hitbox.y.ROLLING
			}
			
			return
		}
	
		u8 input_state = control.player1.state
		s16 vx = char.velocity.x

		s16 maxSpeed = s16[A4]
		s16 acceleration = s16[A4 + 2] * 2

		if (input_state & CONTROL_LEFT)
		{
			if (char.state != char.state.TEKICK)
				char.flags |= char.flag.FACING_LEFT
			
			vx -= acceleration
			if (vx <= -maxSpeed)
			{
				vx += acceleration
				vx = min(vx, -maxSpeed)
			}
		}
		if (input_state & CONTROL_RIGHT)
		{
			if (char.state != char.state.TEKICK)
				char.flags &= ~char.flag.FACING_LEFT
			
			vx += acceleration
			if (vx >= maxSpeed)
			{
				vx -= acceleration
				vx = max(vx, maxSpeed)
			}
		}

		// Center camera y-offset again
		centerCameraYOffset()

		// Air drag
		if (char.velocity.y < 0 && char.velocity.y >= -0x400)  // Not when falling or going up too fast
		{
			s16 drag = vx >> 5		// Do not divide here, as it rounds differently for negative numbers
			if (drag != 0)
			{
				vx -= drag
				if (drag > 0)
					vx = max(vx, 0)
				else
					vx = min(vx, 0)
			}
		}

		char.velocity.x = vx
		
		u8 input_pressed   = control.player1.pressed
		if (input_pressed & CONTROL_B)
		{
			Character.DoTEKick()
		}
	}
	else
	{
		base.Character.UpdateControlInAir()
	}
}


function void Character.DoTEKick()
{
	constant array<u8> STATES =
	{
		0x00, // char.state.RUNNING
		0x01, // char.state.RUNNING2
		0x04, // char.state.PUSHING
		0x05, // char.state.STANDING
		0x07, // char.state.LOOKING_UP
		0x08, // char.state.COWERING
		0x0d, // char.state.BRAKING
		0x10, // char.state.STRAIGHTJUMP
		0x40, // char.state.TEJUMP
	}

	bool validState = false
	
	for (u8 i = 0; i < 9; ++i)
	{
		if (char.state == STATES[i])
		{
			validState = true
		}
	}
	
	// check with objects the player cannot kick on
	A1 = 0xffff0000 + char.object_standing_on
	if (char.flags & char.flag.ON_OBJECT)
	{
		// lbz cylinder
		if (objA1.update_address == 0x02c3ca)
			validState = false
	}
	
	// check if in corkscrew state
	if (char.rotation.x.count != 0)
		validState = false
	
	if (char.state != char.state.TEKICK && char.control_flags == 0 && validState)
	{
		char.double_jump_state = 1
		char.flags2d = 0
		
		if (!super.active)
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
					// kick
					char.flags |= char.flag.IN_AIR
					
					if (char.flags & char.flag.ON_OBJECT)
					{
						char.flags &= ~char.flag.ON_OBJECT
						objA0.position.y.u16 -= 1
					}
					
					u16 acceleration = ((char.flags & char.flag.UNDERWATER) ? 0x080 : 0x200)
					
					u8 angle = char.rotation - 0x40
					s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
					s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

					char.velocity.x += accel_x
					char.velocity.y += accel_y
			}
		}
		else
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
				// sword slash	
				if (abs(char.velocity.x) < 0x800)
				{
					char.groundspeed = ((char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800)
					char.velocity.x = char.groundspeed
				}
			}
		}
		
		char.state = char.state.former
		char.rotation = 0
		
		if (!super.active)
		{
			char.state = char.state.TEKICK
			char.animation.sprite = 1
			Audio.playAudio("te_kick")
		}
		else
		{
			if ((char.flags & char.flag.IN_AIR) == 0)
			{
				char.state = char.state.TEKICK
				char.animation.sprite = 1
				playSound(SFX_SPINDASH_RELEASE)
				
				bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
				if (isHyperSonic)	// Super Sonic's dash does not cause a screen flash
				{
					Character.ClearEnemiesOnScreen()
					ClearPositionBackup()
					u8[0xffffcd7c + 0x20] = 1
				}
			}
			else
			{
				TESonic.DoTEAirSlash()
			}
		}
	}
}

function void TESonic.DoTEAirSlash()
{
	char.jumping = 0
	char.double_jump_state = 2	// Always set this flag; needed for Drop Dash
	bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
	u8 input = control.player1.state & CONTROL_DPAD		// Only directions
	
	char.state = char.state.TEAIRSLASH
	char.spindash_charge = 30

	if (isHyperSonic)	// Super Sonic's dash does not cause a screen flash
	{
		Character.ClearEnemiesOnScreen()
	}

	ClearPositionBackup()

	char.double_jump_state = 1
#if STANDALONE
	if (!isHyperSonic)
		u8[0xffffcbc0 + 0x20] = 1
	else
#endif
		u8[0xffffcd7c + 0x20] = 1

	playSound(SFX_SPINDASH_RELEASE)
	playSound(0x48)

	if (input != 0 && input < 0x0b)		// Not left and right at the same time
	{
		// Perform Jet Dash
		
		if (input & CONTROL_LEFT)
			char.velocity.x = -0x800
		else if (input & CONTROL_RIGHT)
			char.velocity.x = 0x800
		else if (((input & CONTROL_LEFT) == 0) && ((input & CONTROL_RIGHT) == 0))
			char.velocity.x = 0
			
			if (input & CONTROL_UP)
			char.velocity.y = -0x800
		else if (input & CONTROL_DOWN)
			char.velocity.y = 0x800
		else if (((input & CONTROL_UP) == 0) && ((input & CONTROL_DOWN) == 0))
			char.velocity.y = 0

		char.velocity.x = ((char.velocity.x * 3) / 2)
		char.velocity.y = ((char.velocity.y * 3) / 2)
	}
	else
	{
		char.velocity.x = (char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800
		char.velocity.x = ((char.velocity.x * 3) / 2)
		char.velocity.y = 0
	}

#if STANDALONE
	if (!isHyperSonic)
	{
		// Reduce dash speed for Super Sonic
		char.velocity.x = (char.velocity.x > 0) ? (char.velocity.x - 0x200) : (char.velocity.x < 0) ? (char.velocity.x + 0x200) : 0
		char.velocity.y = (char.velocity.y > 0) ? (char.velocity.y - 0x200) : (char.velocity.y < 0) ? (char.velocity.y + 0x200) : 0
	}
#endif

	char.groundspeed = objA0.velocity.x
}

function bool Character.CheckTEKickOverLap(u16 px, u16 py, u16 sx, u16 sy)
{
	s16 y_offset = ((char.render_flags & render_flag.FLIP_Y) ? -16 : -8)

	u16 kickbox_pos_x = D2.u16 + ((char.render_flags & render_flag.FLIP_X) ? -12 : 12)
	u16 kickbox_pos_y = objA0.position.y.u16 + y_offset
	u16 kickbox_size_x = ((!super.active) ? 16 : 48)
	u16 kickbox_size_y = 24
	
	//if (char.state == char.state.TEKICK)
		//debugDrawRect(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, 0x800000ff)
	
	bool kick_overlap = checkBoxOverlap(kickbox_pos_x, kickbox_pos_y, kickbox_size_x, kickbox_size_y, px, py, sx, sy) && char.state == char.state.TEKICK
	//debugLog(kick_overlap)
	
	return kick_overlap
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (TESonic.isTESonic(A0))
	{
		SonicUpdateRingCollection()
		UpdateShieldDeflecting()

		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects()
	}
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
	if (TESonic.isTESonic(A0))
	{
	#if STANDALONE
		// Bounding box of player
		if (DEBUG_DYNAMIC_COLLISIONS)
			debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
	#endif

		u16 numObjects = global.dynamic_objects.size		// Actually it's twice the number of dynamic objects
		A4 = addressof(global.dynamic_objects.size) + 2		// Resulting address: 0xffffe382
		while (numObjects != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			// Offset into a list of hitbox sizes (the list looks a bit random)
			u16 offset = objA1.collision_attributes
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
				//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
				//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
				//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
				//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
				//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
				//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
				//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
				//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
				//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
				//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
				//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
				//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
				//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
				//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
				//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
				//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
				//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
				//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
				//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
				//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
				//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
				//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
				//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
				//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
				//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
				//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
				//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
				//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
				//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
				//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
				//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
				//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
				//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
				//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
				//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
				//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
				//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
				//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
				//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
				//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
				//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
				//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
				//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
				//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
				//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
				//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
				//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
				//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
				//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
				//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
				//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
				//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
				A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS)
				{
					if ((offset & collision_attributes.flags) == collision.flag.ITEM)
						debugDrawRect(px, py, sx, sy, 0x8000ff00)
					else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
						debugDrawRect(px, py, sx, sy, 0x80ff0000)
					else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
						debugDrawRect(px, py, sx, sy, 0x800000ff)
					else
						debugDrawRect(px, py, sx, sy, 0x80ff00ff)
				}
			#endif

				
				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					// Collision found
					Character.OnCollisionWithDynamicObject()
					return
				}
				else if (Character.CheckTEKickOverLap(px, py, sx, sy))
				{
					Character.OnKickCollisionWithDynamicObject()
					return
				}
			}

			numObjects -= 2
		}
	}
	else
	{
		base.Character.CheckCollisionsWithDynamicObjects_partial()
	}
}

//# address-hook(0x00ffd4) end(0x010214)
function void Character.OnCollisionWithDynamicObject()
{
	if (TESonic.isTESonic(A0))
	{
		// Example values for objA1.collision_attributes:
		//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
		//  - 0x0f		 = Boss enemy
		//  - 0x18		 = Extended arm of DEZ Chainspike
		//  - 0x23		 = AIZ Bloominator
		//  - 0x46		 = Monitor
		//  - 0x47		 = Dynamic ring
		//  - 0x87		 = Extended arm of SOZ Skorp
		//  - 0x8b, 0x9c = Flames, damaging parts of enemies
		//  - 0x8f		 = Wrecking ball
		//  - 0x98, 0x9b = Projectile
		//  - 0xd8		 = Thrown mushroom, stars over starpost

		D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
		if (D1.u8 == 0)
		{
			// Collision is an enemy, i.e. is harmful, but can be attacked
			bool attacking = false
			if (char.bonus_effect & char.bonus.INVINCIBLE || char.state == char.state.ROLLING || char.state == char.state.SPINDASH)
			{
				attacking = true
			}

			if (!attacking)
			{
				bool isThreat = false
				if (char.character == CHARACTER_SONIC || char.double_jump_state == 0 || (char.flags & char.flag.UNDERWATER))
				{
					// No real special conditions for Sonic besides the drop dash
					isThreat = true
				}

				if (isThreat)
				{
					Character.OnThreatCollision()
					return
				}
			}

			if (u8[A1 + 0x29] != 0)
			{
				char.velocity.x = -char.velocity.x
				char.velocity.y = -char.velocity.y
				char.groundspeed = -char.groundspeed
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
			}
			else
			{
				if (u8[A1 + 0x2a] & 0x04)
				{
					A2 = 0xffff0000 + u16[A1 + 0x3c]
					u8[A2] &= ~(1 << u8[A1 + 0x3b])
				}

				u8[A1 + 0x2a] |= 0x80

				// Grant bonus points
				Enemy.addScore(A1, 0x010216)

				objA1.update_address = addressof(SmallExplosion.BaseUpdate)
				u8[A1 + 0x05] = 0
				if (char.velocity.y < 0)
				{
					char.velocity.y += 0x100
				}
				else if (char.position.y.u16 >= objA1.position.y.u16)
				{
					char.velocity.y -= 0x100
				}
				else
				{
					char.velocity.y = -char.velocity.y
				}
			}
		}
		else if (D1.u8 == collision.flag.ITEM)
		{
			D0.u8 = (objA1.collision_attributes & collision_attributes.size)
			if (D0.u8 != collision.size.16x16)
			{
				// Collect ring, but only after 30 invulnerability frames
				//  -> Remember that the "char.invuln.countdown" timer starts at 120
				u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
				if (timer < 90)
				{
					u8[A1 + 0x05] = 0x04
				}
			}
			else
			{
				// This part seems to be for monitors specifically
				s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y

				if (A0 != 0xffffb000 && competition_mode.active == 0)
				{
					// Sorry player 2, you can't open monitors in normal game
					return
				}

				bool canOpenMonitor = true

				if (canOpenMonitor)
				{
					objA1.base_state = 0x04		// Set monitor state to broken
					objA1.monitor.character_address = A0.u16		// RAM address of character
				}
			}
		}
		else if (D1.u8 == collision.flag.THREAT)
		{
			// Harmful object
			Character.OnThreatCollision()
		}
		else  // D1.u8 == collision.flag.SPECIAL
		{
			// Other interactable object
			fn0103ba()
		}
	}
	else
	{
		base.Character.OnCollisionWithDynamicObject()
	}
}

function void Character.OnKickCollisionWithDynamicObject()
{
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		if (u8[A1 + 0x29] != 0)
		{
			char.velocity.x = -char.velocity.x
			char.velocity.y = -char.velocity.y
			char.groundspeed = -char.groundspeed
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}

		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)

			objA1.update_address = addressof(SmallExplosion.BaseUpdate)
			u8[A1 + 0x05] = 0
			if (char.velocity.y < 0)
			{
				char.velocity.y += 0x100
			}
			else if (char.position.y.u16 >= objA1.position.y.u16)
			{
				char.velocity.y -= 0x100
			}
			else
			{
				char.velocity.y = -char.velocity.y
			}
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
			if (timer < 90)
			{
				u8[A1 + 0x05] = 0x04
			}
		}
		else
		{
			// This part seems to be for monitors specifically
			s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y

			if (A0 != 0xffffb000 && competition_mode.active == 0)
			{
				// Sorry player 2, you can't open monitors in normal game
				return
			}

			bool canOpenMonitor = true

			if (canOpenMonitor)
			{
				objA1.base_state = 0x04		// Set monitor state to broken
				objA1.monitor.character_address = A0.u16		// RAM address of character
			}
		}
	}
	else if (D1.u8 == collision.flag.THREAT)
	{
		// Harmful object, do nothing
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
	}
}

//# address-hook(0x012172) end(0x012178)
//# address-hook(0x01560c) end(0x01569a)
function void Character.LandingOnGround()
{
	if (TESonic.isTESonic(A0) && char.state == char.state.TEKICK)
	{
		
		if (char.rotation > 0x20 && char.rotation < 0xe0 && (char.flags & char.flag.ROLLING) == 0)
		{
			char.flags &= ~(char.flag.IN_AIR | char.flag.PUSHING | char.flag.CONTROL_LOCK)
			char.state = char.state.RUNNING
			char.animation.timer = 0
			char.rotation.x = 0
		}
		else
		{	
			Character.LandingOnGroundStandUp()
			Character.LandingOnGroundResetState()
		}
	}
	else if (char.state == char.state.TEFUCKINGDIED)
	{
		char.groundspeed = 0
		char.velocity.x = 0
	}
	else
	{
		base.Character.LandingOnGround()
	}
}


function void setSpeedCapProperties(u32 address, bool isSuperActive)
{
	if (TESonic.isTESonic(A0))
	{
		// Set new max speed cap etc.:
		//  - u16[address]     = maximum speed			-> e.g. global.move.speedcap
		//  - u16[address + 2] = maximum acceleration	-> e.g. global.move.acceleration
		//  - u16[address + 4] = maximum deceleration	-> e.g. global.move.deceleration

		if (char.flags & char.flag.UNDERWATER)
		{
			// In water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				u16[address] = max(u16[address], 0x600)
				u16[address + 2] = max(u16[address + 2], 0x0c)
				u16[address + 4] = max(u16[address + 4], 0x40)
			}
			else
		#endif
			if (isSuperActive)
			{
				u16[address] = 0x500
				u16[address + 2] = 0x18
				u16[address + 4] = 0x80
			}
			else
			{
				u16[address] = 0x300
				u16[address + 2] = 0x06
				u16[address + 4] = 0x40
			}
		}
		else
		{
			// Out of water
		#if STANDALONE
			if (char.bonus_effect & char.bonus.SPEED_UP)
			{
				u16[address] = max(u16[address], 0xf00)
				u16[address + 2] = max(u16[address + 2], 0x18)
				u16[address + 4] = max(u16[address + 4], 0x80)
			}
			else
		#endif
			if (isSuperActive)
			{
				u16[address] = 0xa00
				u16[address + 2] = 0x30
				u16[address + 4] = 0x100
			}
			else
			{
				u16[address] = 0x600
				u16[address + 2] = 0x0c
				u16[address + 4] = 0x80
			}
		}
	}
	else
	{
		base.setSpeedCapProperties(address, isSuperActive)
	}
}

//# translated(0x011bde) end(0x011cf0)
//# translated(0x011d16) end(0x011da4)
//# translated(0x0151fc) end(0x01530c)
//# translated(0x015332) end(0x0153c0)
function bool Character.UpdateSpindash()
{
	if (TESonic.isTESonic(A0))
		return false
	else
		return base.Character.UpdateSpindash()
}


function void Character.updateUprightOnGround()
{
	// update on solid ground
	if (TESonic.isTESonic(A0))
	{
		if (Character.UpdateSpindash())
			return

		if (Character.updateSuperPeelout())
			return

		if (Character.CheckStartJump())
			return

		Character.UpdateUprightSlopeEffect()
		Character.updateUprightOnGroundInner()

		Character.sharedUpdateOnGround()
	}
	else
	{
		base.Character.updateUprightOnGround()
	}
}

/*
//# address-hook(0x018cb6) end(0x018d68)
function void fn018cb6()
{
	A1 = 0xffff0000 + objA0.dustcloud.character_address
	if (TESonic.isTESonic(A1))
	{
		A2 = 0xffff0000 + objA0.dustcloud.character_address
		D1 = 0x10
		
		bool isRunning = (u8[A2 + 0x20] == char.state.RUNNING) && (abs(s16[A2 + 0x1c]) >= 0x600) && ((u8[A2 + 0x26] < 0x40) || (u8[A2 + 0x26] > 0xc0)) && ((u8[A2 + 0x2a] & char.flag.IN_AIR) == 0)
		if (u8[A2 + 0x20] != char.state.BRAKING && !isRunning)
		{
				objA0.base_state = 0x02
				u8[A0 + 0x36] = 0
				return
		}

		--u8[A0 + 0x36]
		if (s8[A0 + 0x36] < 0)
		{
			u8[A0 + 0x36] = 3
			if ((u8[A2 + 0x2a] & char.flag.UNDERWATER) == 0)
			{
				if (allocDynamicObjectStd())
				{
					// Spawn skidding dust
					objA1.update_address = objA0.update_address
					objA1.position.x.u16 = u16[A2 + 0x10]
					objA1.position.y.u16 = u16[A2 + 0x14]
					if (objA0.flags38 != 0)
					{
						D1.u16 -= 4
					}
					if (global.inv_gravity)
						D1.s16 = -D1.s16

					objA1.position.y.u16 += D1.u16
					objA1.render_flags = objA0.render_flags
					u8[A1 + 0x05] += 2
					objA1.box_size.x = 4
					objA1.sprite_priority = 0x80
					objA1.sprite_attributes = (objA0.sprite_attributes & ~sprite_attribute.PRIORITY) | (u16[A2 + 0x0a] & sprite_attribute.PRIORITY)
					objA1.mapping_offset = objA0.mapping_offset
					u8[A1 + 0x20] = 3
					u8[A1 + 0x2a] = 0
					objA1.dustcloud.character_address = objA0.dustcloud.character_address
				}
			}
		}

		fn018d6a()
	}
	else
	{
		base.fn018cb6()
	}
}
*/

function void updateCharacterControlOnGround()
{
	if (TESonic.isTESonic(A0))
	{
		u8 input_state     = control.player1.state
		bool isSuperActive = super.active

		D6.u16 = u16[A4] << 1
		D5.u16 = u16[A4 + 2] >> 1
		if (isSuperActive)
		{
			D5.u16 = 6
		}

		if ((char.spindash & 0x80) == 0 && (char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
		{
			if (char.hlock_countdown == 0)
			{
				u16 acceleration = 0x20

				if (input_state & CONTROL_LEFT)
				{
					if (char.groundspeed > 0)
					{
						char.groundspeed -= acceleration
						if (char.groundspeed < 0)
							char.groundspeed = -0x80
					}
					else
					{
						char.flags |= char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}

				if (input_state & CONTROL_RIGHT)
				{
					if (char.groundspeed < 0)
					{
						char.groundspeed += acceleration
						if (char.groundspeed >= 0)
							char.groundspeed = 0x80
					}
					else
					{
						char.flags &= ~char.flag.FACING_LEFT
						char.state = char.state.ROLLING
					}
				}
			}

			if (char.groundspeed != 0)
			{
				if (char.groundspeed > 0)
					char.groundspeed = max(char.groundspeed - D5.s16, 0)
				else
					char.groundspeed = min(char.groundspeed + D5.s16, 0)
			}

			if (abs(char.groundspeed) < 0x80)
			{
				if (char.spindash == 0)
				{
					// Stop rolling
					char.flags &= ~char.flag.ROLLING

					s16 dy = s16(char.hitbox_extends.y) - s16(char.hitbox.default.y)
					char.position.y.u16 += (global.inv_gravity) ? -dy : dy

					char.hitbox_extends.x = char.hitbox.default.x
					char.hitbox_extends.y = char.hitbox.default.y
					char.state = char.state.STANDING
				}
				else
				{
					char.groundspeed = (char.flags & char.flag.FACING_LEFT) ? -0x400 : 0x400
				}
			}
		}

		centerCameraYOffset()

		char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
		char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

		char.velocity.x = clamp(char.velocity.x, -0x1000, 0x1000)

		Character.UpdateControlOnGroundShared()
	}
	else
	{
		base.updateCharacterControlOnGround()
	}
}

//# address-hook(0x012232) end(0x0122b8)
function void SonicLandingBubbleBounce()
{
	if (TESonic.isTESonic(A0))
	{
		// sorry nothing
	}
	else
	{
		base.SonicLandingBubbleBounce()
	}
}

function void gainExtraLife()
{
	// we need to back up and restore the A1 here otherwise the game shits itself
	u32 A1backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (!Game.getSetting(SETTING_INFINITE_LIVES))
		{
			Audio.playAudio("te_1up")
			lives_counter = min(lives_counter + 1, 99)
			++hud.dirty.lives
		}
	}
	else
	{
		base.gainExtraLife()
	}
	
	A1 = A1backup
}

//# address-hook(0x01036e) end(0x0103b8)
function void Character.Die_internal()
{
	if (TESonic.isTESonic(A0))
	{
		TESonic.health = 0
		Character.Die_noSound()
		Audio.playAudio("te_death")
		D0 = 0xffffffff
	}
	else
	{
		base.Character.Die_internal()
	}
}

//# address-hook(0x010366) end(0x01036c)
function void Character.Die()
{
	if (TESonic.isTESonic(A0))
	{
		if (debug_mode.state == 0)
		{
			TESonic.health = 0
			Character.Die_noSound()
			Audio.playAudio("te_death")
		}
		D0 = 0xffffffff
	}
	else
	{
		base.Character.Die()
	}
}

//# address-hook(0x0125ac) end(0x0125da)
function void Character.UpdateDrownedState.Sonic()
{
	TESonic.health = 0
	base.Character.UpdateDrownedState.Sonic()
}

function bool debugModeRescue()
{
	A1 = 0xffffb000
	// Get character out of damage state and into object placement mode
	if (debug_mode.enabled && (control.pad1.pressed & CONTROL_B) && TESonic.isTESonic(A1))
	{
		debug_mode.state = 1
		player1.control_override = 0
		char.invuln.countdown = 120
		
		if (TESonic.health < 1)
			TESonic.health = 1
		
		return true
	}
	
	return base.debugModeRescue()

}

function bool Character.performSuperTransformation()
{
	if (TESonic.isTESonic(A0))
	{
		u8 possibleSuperForm = 0	// 1 for Super, 2 for Hyper
		// Can go super?
		if (global.super_emeralds >= 7)
		{
			possibleSuperForm = 2
		}
		else if (global.chaos_emeralds >= 7 && global.traded_emeralds == 0)
		{
			possibleSuperForm = 1
		}
		
		bool max_health = (TESonic.health == 5 && TESonic.maxhealth == 5)

		if (!max_health)
			return false

		if (!super.active && ring_counter >= 50 && hud.dirty.timer && char.control_flags == 0 && possibleSuperForm != 0)
		{		
			Audio.playAudio("te_sonic")
			TESonic.health = 5
			TESonic.maxhealth = 5
		}
	}
	
	return base.Character.performSuperTransformation()
}

//# address-hook(0x08160a) end(0x081676)
function void fn08160a()
{
	base.fn08160a()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA0.countdown_value >= 0)
			return
			
		Audio.playAudio("te_sonic")
		TESonic.health = 5
		TESonic.maxhealth = 5
	}
}

function void EntryFunctions.sharedInit()
{
	TESonic.health = 3
		
	TESonic.maxhealth = 3	
	base.EntryFunctions.sharedInit()
}

function void Standalone.onLevelStart()
{
	TESonic.health = 3
	if (TESonic.maxhealth < 3)
		TESonic.maxhealth = 3
	
	base.Standalone.onLevelStart()
}

function void Standalone.onRestartLevel()
{
	TESonic.health = 3
	TESonic.maxhealth = 3
	base.Standalone.onRestartLevel()
}

function void Standalone.onRestartAtCheckpoint()
{
	TESonic.health = 3
	
	if (TESonic.maxhealth > 3 || TESonic.maxhealth == 0)
		TESonic.maxhealth = 3
	
	base.Standalone.onRestartAtCheckpoint()
}

function void Standalone.onLevelFinished()
{
	TESonic.health = 3
	
	base.Standalone.onLevelFinished()
}

function void Standalone.onDeath()
{
	TESonic.health = 3
	TESonic.maxhealth = 3

	base.Standalone.onDeath()
}