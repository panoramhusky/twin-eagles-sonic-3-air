include renderhooks
include character
include character_graphics
include render_character
include health_system
include items
include intro
include object_interactions
include jump_off
include mario
include badniks
include fuckles
include continue

include outro

global u8 tesonic.palette
global u8 tesonic.color_scheme
global u8 tesonic.game_rng

constant u8 CHARS_TESONIC = 1 // for global.characters

constant u8 CHARACTER_TESONIC = 0 // for checks

function void Init()
{
	tesonic.game_rng = 0 + (System.rand() % 0xff)
	base.Init()
}

//# address-hook(0x2302fa)
function void FAKE_DUST_CLOUD_BECAUSE_REGULAR_DUST_CLOUD_CODE_SUCKS()
{	
	objA0.position.x.u16 -= u16[0xffffeebc]
	DrawObject()
	UpdateMovementStraightSimple()
	++objA0.animation.timer
	if (objA0.animation.timer > 3)
	{
		if (objA0.animation.sprite < 3)
			++objA0.animation.sprite
		else
		{
			UnloadObject()
			return
		}
			
		objA0.animation.timer = 0
	}
}

//# address-hook(0x0011ca) end(0x0012cc)
function void fn0011ca()
{
	if (levelselect.characters == CHARS_SONIC_AND_TAILS)
	{
		// no partner tails for you lol
		levelselect.characters = CHARS_TESONIC
		global.characters = CHARS_TESONIC
	}
	base.fn0011ca()
}

function string getCharacterLivesIcon(u8 character)
{
	s64 backup = A1 // backing up and restoring A1 is necessary otherwise the game may implode
	A1 = 0xffffb000
	
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u8 palette = tesonic.palette
		
		if (palette == 0xff)
			palette = (tesonic.game_rng % 5)
		
		// this probably could have been done better but idgaf rn
		if (palette == 0x00)
		{
			return "hud_lives_icon_tesonic"
		}
		else if (palette == 0x01)
		{
			return "hud_lives_icon_tesonic_s2"
		}
		else if (palette == 0x02)
		{
			return "hud_lives_icon_tesonic_s6"
		}
		else if (palette == 0x03)
		{
			return "hud_lives_icon_tesonic_s3d5"
		}
		else if (palette == 0x04)
		{
			return "hud_lives_icon_tesonic_sj6"
		}
		else //Failsafe
			return "hud_lives_icon_tesonic_sj6"
	}
	
	return base.getCharacterLivesIcon(character)
}

function string getCharacterBonusTextIcon(u8 character)
{
	s64 backup = A1 // backing up and restoring A1 is necessary otherwise the game may implode
	A1 = 0xffffb000
	
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u8 palette = tesonic.palette
		
		if (palette == 0xff)
			palette = (tesonic.game_rng % 5)
		
		// this probably could have been done better but idgaf rn
		if (palette == 0x00)
		{
			return "hud_bonus_icon_teblue"
		}
		else if (palette == 0x01)
		{
			return "hud_bonus_icon_teblue_s2"
		}
		else if (palette == 0x02)
		{
			return "hud_bonus_icon_teblue_s6"
		}
		else if (palette == 0x03)
		{
			return "hud_bonus_icon_teblue_s3d5"
		}
		else if (palette == 0x04)
		{
			return "hud_bonus_icon_teblue_sj6"
		}
		else //Failsafe
			return "hud_bonus_icon_teblue_s6"
	}
	
	return base.getCharacterBonusTextIcon(character)
}

function string getCharacterContinueIcon(u8 character)
{
	s64 backup = A1 // backing up and restoring A1 is necessary otherwise the game may implode
	A1 = 0xffffb000
	
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u8 palette = tesonic.palette
		
		if (palette == 0xff)
			palette = (tesonic.game_rng % 5)
		
		// this probably could have been done better but idgaf rn
		if (palette == 0x00)
		{
			return "continue_icon_tesonic"
		}
		else if (palette == 0x01)
		{
			return "continue_icon_tesonic_s2"
		}
		else if (palette == 0x02)
		{
			return "continue_icon_tesonic_s6"
		}
		else if (palette == 0x03)
		{
			return "continue_icon_tesonic_s3d5"
		}
		else if (palette == 0x04)
		{
			return "continue_icon_tesonic_sj6"
		}
		else //Failsafe
			return "continue_icon_tesonic_s3d5"
	}
	
	return base.getCharacterContinueIcon(character)
}

function string getCharacterResultsNameplate(u8 character)
{
	s64 backup = A1 // backing up and restoring A1 is necessary otherwise the game may implode
	A1 = 0xffffb000
	
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u8 palette = tesonic.palette
		
		if (palette == 0xff)
			palette = (tesonic.game_rng % 5)
		
		// this probably could have been done better but idgaf rn
		if (palette == 0x00)
		{
			return "result_nameplate_tesonic"
		}
		else if (palette == 0x01)
		{
			return "result_nameplate_tesonic_s2"
		}
		else if (palette == 0x02)
		{
			return "result_nameplate_tesonic_s6"
		}
		else if (palette == 0x03)
		{
			return "result_nameplate_tesonic_s3d5"
		}
		else if (palette == 0x04)
		{
			return "result_nameplate_tesonic_sj6"
		}
		else //Failsafe
			return ""
	}
	
	return base.getCharacterResultsNameplate(character)
}

function string getCharacterPaletteKey(u8 character)
{
	A1 = 0xffffb000
	if (character == CHARACTER_TESONIC)
	{
		if (tesonic.palette != 0xff)
			return TESonic.getPaletteType(tesonic.palette)
		else
		{
			u8 random = (tesonic.game_rng % 5)
			return TESonic.getPaletteType(random)
		}

	}

	return base.getCharacterPaletteKey(character)
}

function string TESonic.getPaletteType(u8 palette)
{
	// this probably could have been done better with a stringformat but idgaf rn
	if (palette == 0x00)
	{
		if (tesonic.color_scheme == 0)
			return "character_palette_sonic_s4_r"
		else
			return "character_palette_sonic_s4"
	}
	else if (palette == 0x01)
	{
		if (tesonic.color_scheme == 0)
			return "character_palette_sonic_s2_r"
		else
			return "character_palette_sonic_s2"
	}
	else if (palette == 0x02)
	{
		if (tesonic.color_scheme == 0)
			return "character_palette_sonic_s6_r"
		else
			return "character_palette_sonic_s6"
	}
	else if (palette == 0x03)
	{
		if (tesonic.color_scheme == 0)
			return "character_palette_sonic_s3d5_r"
		else
			return "character_palette_sonic_s3d5"
	}
	else if (palette == 0x04)
	{
		// we don't need a rendered check here because the palette is already a genesis palette! :D
			return "character_palette_sonic_sj6"
	}
	else //Failsafe, might end up making this the broken s4 results palette for shits and giggles later
		return "character_palette_sonic_s4_r"
}

function u64 Standalone.getModdedSoundKey(u64 soundKey, u8 sfxId, u8 soundRegType)
{
	s64 backup = A1 // backing up and restoring A1 is necessary otherwise the game explodes
	A1 = 0xffffb000
	
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		
		if (objA0.update_address == 0x010a94)
		{
			if (sfxId == SFX_BRAKE)
				soundKey = "te_skid"
			else if (sfxId == 0x35)
				soundKey = "te_hurt"
			else if (sfxId == SFX_JUMP)
				soundKey = "te_jump"
		}
		
		if (levelselect.characters == CHARS_TESONIC)
		{
			if (sfxId == MUSIC_SUPER)
			{
				u8 configOption = Game.getSetting(SETTING_AUDIO_SUPER_THEME)
				if (configOption >= 2)
					soundKey = "supertheme_te"
			}
			
			if (sfxId == MUSIC_DDZ)
			{
				soundKey = "supertheme_te"
			}
		}
		
		return soundKey
	}
	
	A1 = backup
	
	return base.Standalone.getModdedSoundKey(soundKey, sfxId, soundRegType)
}

function bool TESonic.isTESonic(u32 address)
{
	if (u8[address + 0x38] == CHARACTER_TESONIC && global.characters == CHARS_TESONIC)
		return true
	else
		return false
}

function u32 TESonic.ScanandReturnAddressInRAM(u32 update_address)
{
	u32 ram_address = 0xffffb000
	for (u32 position = 0; position <= 0xffffffff; position += 0x4a)
	{
		A3 = ram_address + position
		if (u32[A3] == update_address)
		{
			break
		}
		else if (ram_address == 0xffffcf82)
		{
			// quick hack to stop for loop, probably a better way to do this
			A3 = 0
			string message = stringformat("Couldn't find update address %02x in any object slot", update_address)
			assert(false, message)
			break
		}
	}
	return A3
}

function bool TESonic.checkIfBombCollidingWithBoss()
{
	u16 px1 = objA0.position.x.u16 - 8
	u16 py1 = objA0.position.y.u16 - 4
	u16 bx1 = 16
	u16 by1 = 10
	
	u16 px2 = objA1.position.x.u16 - 16
	u16 py2 = objA1.position.y.u16 - 8
	u16 bx2 = 32
	u16 by2 = 32
	
	//Debug.drawRect(px1, py1, bx1, by1, 0x0000ff88)
	//Debug.drawRect(px2, py2, bx2, by2, 0xff000088)
	
	bool colliding = checkBoxOverlap(px1, py1, bx1, by1, px2, py2, bx2, by2)
	return colliding
}

function bool TESonic.checkIfBallCollidingWithBoss()
{
	u16 px1 = objA0.position.x.u16 - 8
	u16 py1 = objA0.position.y.u16 - 8
	u16 bx1 = 16
	u16 by1 = 16
	
	u16 px2 = objA1.position.x.u16 - 16
	u16 py2 = objA1.position.y.u16 - 16
	u16 bx2 = 32
	u16 by2 = 32
	
	//Debug.drawRect(px1, py1, bx1, by1, 0x0000ff88)
	//Debug.drawRect(px2, py2, bx2, by2, 0xff000088)
	
	bool colliding = checkBoxOverlap(px1, py1, bx1, by1, px2, py2, bx2, by2)
	return colliding
}