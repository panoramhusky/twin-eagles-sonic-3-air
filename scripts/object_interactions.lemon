function bool TESonic.checkIfKickFacingObject()
{
	bool facing = false
	
	A1 = 0xffffb000
	bool facingLeft = (objA1.render_flags & render_flag.FLIP_X)
	bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
	if (onLeft && !facingLeft)
	{
		// facing right, on left side of object
		facing = true
	}
	else if (!onLeft && facingLeft)
	{
		facing = true
	}
	
	return facing
}

// signpost
function void fn083a70()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		A1 = 0xffff0000 + D0.u16
		if (u8[A1 + 0x20] != char.state.TEKICK)
			return
			
		if (!TESonic.checkIfKickFacingObject())
			return
			
		if (objA1.velocity.y >= 0)
			return

		// Touched by character
		objA0.state = 0x20
		D0.u16 = objA0.position.x.u16 - objA1.position.x.u16
		if (D0.u16 == 0)
			D0 = 8

		D0.u16 <<= 4
		objA0.velocity.x = D0.u16
		objA0.velocity.y = -0x200

		playSound(0xb8)

		// "spawnSimpleChildObjects(0x083b3c)" replaced by:
		spawnSimpleChildObjects(addressof(FloatingPoints.Init), 1)

		A3 = A1
		addScore(10)
	}
	else
	{
		A1 = backup
		base.fn083a70()
	}
}

// spikes
//# address-hook(0x024280) end(0x0242b4)
function void DamageCharacter()
{
	if (TESonic.isTESonic(A1))
	{
		if ((u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0)
		{
			if (u8[A1 + 0x34] == 0 && u8[A1 + 0x05] < base_state.HURT)
			{
				D0 = s32(objA1.velocity.y) << 8
				D3 = objA1.position.y - D0
				objA1.position.y = D3
				A2 = A0
				A0 = A1

				// Hurt character
				Character.Die_internal()
				A0 = A2
			}
		}
	}
	else
	{
		base.DamageCharacter()
	}
}

// electric floor/lava
//# address-hook(0x01f58c) end(0x01f59e)
function void BlockerElement.DoDamage()
{
	if (TESonic.isTESonic(A1))
	{
		D0.u8 = objA0.flags2b & (char.bonus.ALL_SHIELDS | char.bonus.INVINCIBLE)
		if ((D0.u8 & u8[A1 + 0x2b]) == 0 && u8[A1 + 0x34] == 0 && !super.active)
		{
			if (objA0.flags2b & char.bonus.SHIELD_LIGHTNING)
			{
				TESonic.health = 0
				A1 = A0
				A0 = 0xffffb000
				TESonic.ZaptheFucker()
				A0 = A1
			}
			else if (objA0.flags2b & char.bonus.SHIELD_FIRE)
			{
				TESonic.health = 0
				A1 = A0
				A0 = 0xffffb000
				TESonic.BurntheFucker()
				A0 = A1
				
				TESonic.SpawnSmoke()
			}
			return
		}
	}
	
	base.BlockerElement.DoDamage()
}

function void TESonic.SpawnSmoke()
{
	A2 = 0xffffb000
	u16 pos_x = u16[A2 + 0x10]
	u16 pos_y = u16[A2 + 0x14]
	if (allocDynamicObjectStd())
	{
		// Spawn skidding dust
		objA1.update_address = 0x2302fa
		objA1.render_flags = objA0.render_flags
		u8[A1 + 0x05] += 0x02
		objA1.box_size.x = 0x04
		objA1.sprite_priority = 0x80
		objA1.sprite_attributes = (u16[A0 + 0x0a] & sprite_attribute.PRIORITY)
		objA1.position.x.u16 = pos_x
		objA1.position.y.u16 = pos_y
		objA1.velocity.x = 0x100
		objA1.velocity.y = 0x100
	}
	
	if (allocDynamicObjectStd())
	{
		// Spawn skidding dust
		objA1.update_address = 0x2302fa
		objA1.render_flags = objA0.render_flags
		u8[A1 + 0x05] += 0x02
		objA1.box_size.x = 0x04
		objA1.sprite_priority = 0x80
		objA1.sprite_attributes = (u16[A0 + 0x0a] & sprite_attribute.PRIORITY)
		objA1.position.x.u16 = pos_x
		objA1.position.y.u16 = pos_y
		objA1.velocity.x = -0x100
		objA1.velocity.y = 0x100
	}
	
	if (allocDynamicObjectStd())
	{
		// Spawn skidding dust
		objA1.update_address = 0x2302fa
		objA1.render_flags = objA0.render_flags
		u8[A1 + 0x05] += 0x02
		objA1.box_size.x = 0x04
		objA1.sprite_priority = 0x80
		objA1.sprite_attributes = (u16[A0 + 0x0a] & sprite_attribute.PRIORITY)
		objA1.position.x.u16 = pos_x
		objA1.position.y.u16 = pos_y
		objA1.velocity.x = -0x100
		objA1.velocity.y = -0x100
	}
	
	if (allocDynamicObjectStd())
	{
		// Spawn skidding dust
		objA1.update_address = 0x2302fa
		objA1.render_flags = objA0.render_flags
		u8[A1 + 0x05] += 0x02
		objA1.box_size.x = 0x04
		objA1.sprite_priority = 0x80
		objA1.sprite_attributes = (u16[A0 + 0x0a] & sprite_attribute.PRIORITY)
		objA1.position.x.u16 = pos_x
		objA1.position.y.u16 = pos_y
		objA1.velocity.x = 0x100
		objA1.velocity.y = -0x100
	}
}

// rocks
//# address-hook(0x01fd08) end(0x01ff1a)
function void fn01fd08()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
		u16[A0 + 0x36] = u16[0xffffb04a + 0x18]

		D1 = objA0.box_size.x + 11
		D2 = objA0.box_size.y
		D3.u16 = D2.u16 + 1
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		D6 = (D6 << 16) + (D6 >> 16)
		if (D6.u16 & 0x03)
		{
			bool canBreakWall = false

			A1 = 0xffffb000
			D1.u16 = u16[A0 + 0x30]
			if (D6.u16 & 0x01)
			{
				if ((objA0.subtype2c & 0x80) == 0)	// Special Knuckles-only wall?
				{
					if (super.active || (TESonic.isTESonic(A1) && objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject()))
					{
						// Super form breaks walls even when going slow
						canBreakWall = true
					}
					else if ((objA0.flags2a & object.flag.P1_PUSHING))
					{
						// Normal Sonic and Tails need to quickly roll into a wall to break it (this includes the fire shield attack)
						canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x480)
					}
				}

				if (canBreakWall)
				{
					objA0.flags2a &= ~object.flag.P1_PUSHING
					Rocks.BreakWall()
				}
			}
		}

		if (competition_mode.active == 0)
		{
			if (checkForUnloadObjectAtPosition(objA0.countdown_value))
				return
		}
		DrawObject()
	}
	else
	{
		A1 = backup
		base.fn01fd08()
	}
}

// breakable wall
//# address-hook(0x021568) end(0x021690)
function void fn021568()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
		objA0.value32 = u16[0xffffb04a + 0x18]

		D1 = objA0.box_size.x + 11
		D2 = objA0.box_size.y
		D3.u16 = D2.u16 + 1
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		if (u8[A0 + 0x2c] & 0x80)
		{
			if (level.trigger00 == 0)
			{
				DrawOrUnloadObject()
			}
			else
			{
				UnloadObject()
			}
			return
		}

		D6 = (D6 << 16) + (D6 >> 16)
		D6.u16 &= 0x03
		if (D6.u16 == 0)
		{
			DrawOrUnloadObject()
			return
		}

		A1 = 0xffffb000
		D1.u16 = u16[A0 + 0x30]
		if (D6.u16 & 0x01)
		{
			bool canBreakWall = false
			if (super.active || (TESonic.isTESonic(A1) && objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject()))
			{
				// Super/Hyper forms can break walls, and Knuckles can
				canBreakWall = true
			}
			else
			{
				// Does this wall allow for rolling into the wall? Otherwise the fire shield will do
				if ((objA0.flags2a & object.flag.P1_PUSHING))
				{
					canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
				}
			}

			if (canBreakWall)
			{
				objA0.flags2a &= ~object.flag.P1_PUSHING
				fn02165a()

				DrawOrUnloadObject()
				return
			}
		}

		A1 = 0xffffb04a
		D1.u16 = objA0.value32
		if ((objA0.flags2a & object.flag.P2_PUSHING) && objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
		{
			objA0.flags2a &= ~object.flag.P2_PUSHING
			fn02165a()

		#if STANDALONE
			if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2)
			{
				// Prevent slope glitch here for player 1
				if ((u8[0xffffb000 + 0x2a] & char.flag.ON_OBJECT) && u16[0xffffb000 + 0x42] == A0.u16)
				{
					u8[0xffffb000 + 0x2a] &= ~char.flag.ON_OBJECT
					u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
				}
			}
		#endif
		}
	#if STANDALONE
		else if (global.zone == 0x02)
		{
			// In MGZ, make all normal breakable walls also breakable by spinning top
			D6 = (D6 << 16) + (D6 >> 16)
			fn021758()
		}
	#endif
		else
		{
			DrawOrUnloadObject()
		}
	}
	else
	{
		A1 = backup
		base.fn021568()
	}
}

// aiz rock thats breakable from the top
//# address-hook(0x01faf2) end(0x01fb4a)
function void Rocks.Update()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1) && objA0.subtype2c & 0x01)
	{
		A1 = backup
		objA0.update_address = 0x01fd08
	}
	else
	{
		A1 = backup
		base.Rocks.Update()
	}
}

//hcz 2 boss bomb
//# address-hook(0x06b734) end(0x06b734)
function void fn06b734()
{
	if (objA0.value3b == 0)
	{
		base.fn06b734()
		A1 = 0xffffb000
		if (TESonic.isTESonic(A1))
		{
			u16 charpos_x = objA1.position.x.u16
			u16 charpos_y = objA1.position.y.u16
			
			u16 offset_x = objA0.hitbox_extends.x
			u16 offset_y = objA0.hitbox_extends.y
			
			u16 blockpos_x = objA0.position.x.u16
			u16 blockpos_y = objA0.position.y.u16
			
			bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 16)
			bool inBoundRight = (charpos_x < blockpos_x + offset_x + 16)
			bool inBoundTop = (charpos_y > blockpos_y - offset_y - 16)
			bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 16)

			if ((inBoundLeft && inBoundRight && inBoundTop && inBoundBottom) && objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject())
			{
				objA0.value3b = 1
				playSound(0x5d)
				
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				objA0.velocity.x = (onLeft ? 0x100 : -0x100) + objA1.velocity.x
				objA0.velocity.y = -0x680
				objA0.countdown_callback = 0x06b73a
				
				u8[A1 + 0x05] = base_state.NORMAL
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				objA1.velocity.y = -0x300
				objA1.flags2a |= (char.flag.IN_AIR)
				objA1.flags2a &= ~char.flag.ON_OBJECT
			}
		}
	}
	else
	{
		MoveWithGravity20()
		
		objA0.animation.sprite = ((level.framecounter & 0x01) ? 6 : 7)
		
		objA0.box_size.x = 8
		
		Object.TriggerOnGroundHit()
		
		A1 = TESonic.ScanandReturnAddressInRAM(0x06af0c)
		
		if (!TESonic.checkIfBombCollidingWithBoss())
			return
			
		u8[A1 + 0x1c] = A0.u8
		u8[A1 + 0x25] = u8[A1 + 0x28]
		u8[A1 + 0x28] = 0
		--u8[A1 + 0x29]
		if (u8[A1 + 0x29] == 0)
		{
			u8[A1 + 0x2a] |= 0x80
		}
		
		playSound(0x4e)
		// "spawnChildObjects(0x06bdb2)" replaced by:
		spawnChildObject(0x06b77c, 0x00, 0, 0)
		
		Object.TriggerUnloading()
	}
}

// MGZ spin dash wheel
//# address-hook(0x025d9c) end(0x025ea0)
function void fn025d9c()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		D1.u16 = 0x1b
		D2.u16 = 0x10
		D4.u16 = objA0.position.x.u16
		A2 = 0x025f0e
		fn01dd0e()

		D6 = (D6 << 16) + (D6 >> 16)
		D6.u16 &= 0x33
		if (D6.u16 != 0)
		{
			D0.u8 = D6.u8 & 0x11
			if (D0.u8 != 0)
			{
				A1 = 0xffffb000
				if (objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject())
				{
					u16[A0 + 0x30] = 0x3c
					u8[A0 + 0x32] = 1
					D0.u8 = (u8[A1 + 0x2a] + objA0.flags2a) & 0x01
					if (D0.u8 == 0)
					{
						u8[A0 + 0x32] = 0xff
					}
					
					playSound(0x8e)
					
					bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
					
					u8[A1 + 0x05] = base_state.NORMAL
					objA1.velocity.x = (onLeft ? -0x200 : 0x200)
					objA1.velocity.y = -0x380
					objA1.flags2a |= (char.flag.IN_AIR)
					objA1.flags2a &= ~char.flag.ON_OBJECT
					objA1.state = char.state.TEFUCKINGDIED
				}
			}
		}

		if (u16[A0 + 0x30] != 0)
		{
			D0.u16 = objA0.subtype2c & 0x0f
			A3 = 0xfffff7e0 + D0.u16

			--u16[A0 + 0x30]
			if (u16[A0 + 0x30] == 0)
			{
				u8[A3] = 0
				objA0.animation.sprite = 0
			}
			else
			{
				u8[A3] = 1
				if (objA0.flags2a & object.flag.P1_ON_OBJECT)
				{
					A1 = 0xffffb000
					fn025ea6()
				}

				--objA0.animation.timer
				if (s8(objA0.animation.timer) < 0)
				{
					objA0.animation.timer = 1
					objA0.compound.sprite1.animation.sprite = (objA0.compound.sprite1.animation.sprite + u8[A0 + 0x32]) & 0x03
				}
				objA0.animation.sprite = (objA0.animation.sprite != 0) ? 0 : 4
			}
		}

		DrawOrUnloadObject()
	}
	else
	{
		A1 = backup
		base.fn025d9c()
	}
}

// cork floor >:(
//# address-hook(0x02a502) end(0x02a586)
function void fn02a502()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u16[A0 + 0x38] = score.bonus_counter
		u8[A0 + 0x34] = u8[0xffffb000 + 0x20]
		u8[A0 + 0x36] = u8[0xffffb04a + 0x20]
		D1 = objA0.box_size.x + 11
		D2 = objA0.box_size.y
		D3.u16 = D2.u16 + 1
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		D0.u16 = objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)
		if (D0.u16 == 0)
		{
			DrawOrUnloadObject()
			return
		}

		if (D0.u8 == (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT))
		{
			if (u8[A0 + 0x34] != 2 && u8[A0 + 0x36] != 2)
			{
				DrawOrUnloadObject()
				return
			}

			A1 = 0xffffb000
			D0.u8 = u8[A0 + 0x34]
			fn02a588()

			A1 = 0xffffb04a
			D0.u8 = u8[A0 + 0x36]
			fn02a588()

			fn02a5d8()
		}
		else
		{
			D1.u8 = D0.u8 & object.flag.P1_ON_OBJECT
			if (D1.u8 == 0)
			{
				fn02a5c0()
				return
			}

			if (u8[A0 + 0x34] != char.state.TEJUMP && u8[A0 + 0x34] != char.state.TEAIRSLASH && u8[A0 + 0x34] != char.state.ROLLING)
			{
				DrawOrUnloadObject()
				return
			}

			A1 = 0xffffb000
			fn02a58e()
			fn02a5d8()
		}
	}
	else
	{
		A1 = backup
		base.fn02a502()
	}
}

// oughhh more cork floor >:((
//# address-hook(0x02a58e)
function void fn02a58e()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1) && (objA1.state == char.state.TEJUMP || objA1.state == char.state.TEAIRSLASH || objA1.state == char.state.ROLLING))
	{
		objA1.flags2a |= char.flag.IN_AIR
		objA1.flags2a &= ~char.flag.ON_OBJECT
		objA1.velocity.y = -0x300
		u8[A1 + 0x05] = base_state.NORMAL
		
		if (objA1.state == char.state.TEAIRSLASH)
		{
			objA1.state = char.state.ROLLING
			objA1.groundspeed = 0x800
		}
	}
	else
	{
		A1 = backup
		base.fn02a58e()
	}
}

// bumper
//# address-hook(0x032f56) end(0x032fee)
function void fn032f56()
{
	base.fn032f56()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH)
		{
			if (super.active)
			{
				objA0.update_address = addressof(SmallExplosion.BaseUpdate)
				objA0.base_state = 0x02
				u8[A0 + 0x28] = 0
				u8[A0 + 0x29] = 0
			}
		
			A2 = A0
			A0 = A1
			Character.LandingOnGroundNoSpindash()
			char.flags |= char.flag.IN_AIR
			char.groundspeed = 0
			char.state = char.state.TEFUCKINGDIED
			playSound(0x35)
			playSound(0x49)
			A0 = A2
		}
	}
}

// cnz button
//# address-hook(0x065d8c) end(0x065dd0)
function void fn065d8c()
{
	base.fn065d8c()

	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT))
		{
			objA0.update_address = addressof(SmallExplosion.BaseUpdate)
			objA0.base_state = 0x02
			u8[A0 + 0x28] = 0
			u8[A0 + 0x29] = 0
			
			objA1.flags2a &= ~char.flag.ON_OBJECT
		}
	}
}

// cnz button (real)
function void Button.checkIfPressed()
{
	// mod compat by accident? cnz button mod uses a different object for the button to turn the lights back on

	base.Button.checkIfPressed()
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		// This points to one of "level.trigger00" ... "level.trigger0f"
		A3 = 0xfffff7e0 + (objA0.subtype2c & 0x0f)

		if ((objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)) && objA0.subtype2c == 0x00 && global.zone_act.apparent == 0x0301)
		{
			// Button is pressed
			if (u8[A3] == 0)
			{
				playSound(SFX_CLICK)
			}
			
			objA0.update_address = addressof(SmallExplosion.BaseUpdate)
			objA0.base_state = 0x02
			u8[A0 + 0x28] = 0
			u8[A0 + 0x29] = 0
			
			objA1.flags2a &= ~char.flag.ON_OBJECT
		}
	}
}


// cnz boss ball
//# address-hook(0x06e8a2) end(0x06e8b0)
function void fn06e8a2()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA1.state == char.state.TEKICK)
		{
			if (TESonic.CheckForCNZBallKick() && objA0.value3b != 2 && TESonic.checkIfKickFacingObject())
			{
				objA0.base_state = 0x04
				objA0.countdown_callback = 0x06e8b6
				u32[A0 + 0x30] = 0x06ee1d
				
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				objA0.velocity.x = (onLeft ? 0x400 : -0x400)
				objA0.velocity.y = -0x700
				
				objA0.value3b = 1 // indicate boss can be hit with ball now
				playSound(0x49)
				
				A1 = 0xffffb000
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				objA1.velocity.y = -0x300
				objA1.flags2a |= (char.flag.IN_AIR)
				objA1.flags2a &= ~char.flag.ON_OBJECT
				
				A1 = 0xffff0000 + u16[A0 + 0x46]
				objA1.base_state = 0x06
				objA1.flags38 |= 0x02
				objA1.velocity.x = 0
			}
		}
		
		if (objA0.value3b == 1)
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			if (TESonic.checkIfBallCollidingWithBoss())
			{
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
				
				objA0.velocity.x = -clamp(objA0.velocity.x, -0x200, 0x200)
				objA0.velocity.y = 0x80
				objA0.value3b = 2
			}
		}
		else if (objA0.value3b == 2)
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			Object.AnimationProgressByLocalA1.DistinctTimer()
		}
	}

	A1 = backup
	base.fn06e8a2()
}

// another cnz ball
//# address-hook(0x06e8e8) end(0x06e8fc)
function void fn06e8e8()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA1.state == char.state.TEKICK)
		{
			if (TESonic.CheckForCNZBallKick() && objA0.value3b != 2 && TESonic.checkIfKickFacingObject())
			{
				objA0.base_state = 0x04
				objA0.countdown_callback = 0x06e8b6
				u32[A0 + 0x30] = 0x06ee1d
				
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				objA0.velocity.x = (onLeft ? 0x400 : -0x400)
				objA0.velocity.y = -0x700
				
				objA0.value3b = 1 // indicate boss can be hit with ball now
				playSound(0x49)
				
				A1 = 0xffffb000
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				objA1.velocity.y = -0x300
				objA1.flags2a |= (char.flag.IN_AIR)
				objA1.flags2a &= ~char.flag.ON_OBJECT
				
				A1 = 0xffff0000 + u16[A0 + 0x46]	
				objA1.base_state = 0x06
				objA1.flags38 |= 0x02
				objA1.velocity.x = 0
			}
		}
		
		if (objA0.value3b == 2)
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			Object.AnimationProgressByLocalA1.DistinctTimer()
		}
	}

	A1 = backup
	base.fn06e8e8()
}

// more cnz ball
//# address-hook(0x06e8fe) end(0x06e91c)
function void fn06e8fe()
{
	base.fn06e8fe()
	
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = 0xffff0000 + u16[A0 + 0x46]
		if (u8[A1 + 0x38] & 0x08)
			return

		objA0.value3b = 0 // reset kicking state
	}
}

function bool TESonic.CheckForCNZBallKick()
{
	A1 = 0xffffb000
	u16 charpos_x = objA1.position.x.u16
	u16 charpos_y = objA1.position.y.u16
	
	u16 offset_x = objA0.box_size.x
	u16 offset_y = objA0.box_size.y
	
	u16 blockpos_x = objA0.position.x.u16
	u16 blockpos_y = objA0.position.y.u16
	
	bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 8)
	bool inBoundRight = (charpos_x < blockpos_x + offset_x + 8)
	bool inBoundTop = (charpos_y > blockpos_y - offset_y - 8)
	bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 8)

	if ((inBoundLeft && inBoundRight && inBoundTop && inBoundBottom))
		return true
	else
		return false
}

// icz ice jenga
//# translated(0x08ac80) end(0x08accc)
function bool fn08ac80()
{
	if (TESonic.isTESonic(A1))
	{
		u8 bit = (1 << D1.u8)

		u16 charpos_x = objA1.position.x.u16
		u16 charpos_y = objA1.position.y.u16
		
		u16 offset_x = objA0.box_size.x
		u16 offset_y = objA0.box_size.y
		
		u16 blockpos_x = objA0.position.x.u16
		u16 blockpos_y = objA0.position.y.u16
		
		bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
		bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
		bool inBoundTop = (charpos_y > blockpos_y - offset_y - 16)
		bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 16)

		if (inBoundLeft && inBoundRight && inBoundTop && inBoundBottom)
		{
			bool TEKick = (objA1.state == char.state.TEKICK && objA1.animation.sprite == 0x03 && TESonic.checkIfKickFacingObject())
			bool superSlash = (super.active && objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject())
			bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
		
			// To break through, the character needs to kick it
			if (TEKick || superSlash)
			{
				if (objA0.value3a >= 1 || superSlash)
				{
					u8[A1 + 0x2a] &= ~bit

					objA0.flags2a &= ~bit
					objA0.flags38 |= 0x01
					
					if (superSlash)
					{
						objA1.hitbox_extends.x = char.hitbox.x.ROLLING
						objA1.hitbox_extends.y = char.hitbox.y.ROLLING
						objA1.state = char.state.ROLLING
						objA1.flags2a |= char.flag.ROLLING
						objA1.velocity.x = (onLeft ? 0xa00 : -0xa00)
						objA1.groundspeed = objA1.velocity.x
					}
					else
					{
						objA1.velocity.x = (onLeft ? -0x200 : 0x200)
						objA0.position.x.u16 += (onLeft ? 0x08 : -0x08)
					}

					// "spawnChildObjects(0x08aaea)" replaced by:
					spawnChildObject(0x08a8dc, 0x00, -12, -8)
					spawnChildObject(0x08a8dc, 0x02, -4, -8)
					spawnChildObject(0x08a8dc, 0x04, 4, -8)
					spawnChildObject(0x08a8dc, 0x06, 12, -8)
					spawnChildObject(0x08a8dc, 0x08, -12, 0)
					spawnChildObject(0x08a8dc, 0x0a, -4, 0)
					spawnChildObject(0x08a8dc, 0x0c, 4, 0)
					spawnChildObject(0x08a8dc, 0x0e, 12, 0)
					spawnChildObject(0x08a8dc, 0x10, -12, 8)
					spawnChildObject(0x08a8dc, 0x12, -4, 8)
					spawnChildObject(0x08a8dc, 0x14, 4, 8)
					spawnChildObject(0x08a8dc, 0x16, 12, 8)

					fn08594e()
					Object.TriggerUnloading()
					playSound(SFX_COLLAPSE)
					return true
				}
				else
				{
					if (objA0.value3a == 0)
					{
						playSound(0x5d)
					}
					
					objA1.velocity.x = (onLeft ? -0x200 : 0x200)
					
					objA0.position.x.u16 += (onLeft ? 0x08 : -0x08)
					
					objA0.value3a += 1
				}
			}
		}
	}
	
	return base.fn08ac80()
}

// icz ice block
//# address-hook(0x08b384) end(0x08b3a4)
function void fn08b384()
{
	base.fn08b384()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		D6 = (D6 << 16) + (D6 >> 16)
		if (D6.u16 & 0x03)
		{
			if ((objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
			{
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				u8[A1 + 0x05] = base_state.NORMAL
				
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				objA1.velocity.y = -0x300
				
				if (objA1.state == char.state.TEAIRSLASH)
				{
					objA1.state = char.state.ROLLING
					objA1.groundspeed = 0x800
				}
				
				objA1.flags2a |= (char.flag.IN_AIR)
				objA1.flags2a &= ~char.flag.ON_OBJECT

				if (A2 != 0)
				{
					u8[A2 + 0x2a] |= char.flag.IN_AIR
					u8[A2 + 0x2a] &= ~char.flag.ON_OBJECT
				}

				// Spawn broken ice block chunks
				// "spawnChildObjects(0x08b480)" replaced by:
				spawnChildObject(0x08b432, 0x00, 0, -8)
				spawnChildObject(0x08b432, 0x02, 0, 8)
				spawnChildObject(0x08b432, 0x04, -16, -8)
				spawnChildObject(0x08b432, 0x06, 16, -8)
				spawnChildObject(0x08b432, 0x08, -16, 8)
				spawnChildObject(0x08b432, 0x0a, 16, 8)
				spawnChildObject(0x08b432, 0x0c, 0, 0)
				spawnChildObject(0x08b432, 0x0e, 0, 0)
				spawnChildObject(0x08b432, 0x10, 0, 0)
				spawnChildObject(0x08b432, 0x12, 0, 0)
				spawnChildObject(0x08b432, 0x14, 0, 0)
				spawnChildObject(0x08b432, 0x16, 0, 0)

				playSound(0x6e)
				Object.TriggerUnloading()
			}
		}
	}
}

// icz ice block again
//# address-hook(0x08b3aa) end(0x08b430)
function void fn08b3aa()
{
	base.fn08b3aa()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		// Note that this differs from the original code (usage of A2)
		//  -> Needed for standalone to fix the known bugs here

		// Any character on top rolling?
		A2 = 0
		if ((objA0.flags2a & object.flag.P1_ON_OBJECT) && (objA0.value3a == char.state.ROLLING || objA0.value3a == char.state.TEAIRSLASH))
		{
			A1 = 0xffffb000
		}
		else
		{
			return
		}

		u8[A1 + 0x05] = base_state.NORMAL
		objA1.velocity.y = -0x300
		objA1.hitbox_extends.x = char.hitbox.x.ROLLING
		objA1.hitbox_extends.y = char.hitbox.y.ROLLING
		objA1.state = char.state.ROLLING
		objA1.groundspeed = 0x800
		objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
		objA1.flags2a &= ~char.flag.ON_OBJECT
		
		// Spawn broken ice block chunks
		// "spawnChildObjects(0x08b480)" replaced by:
		spawnChildObject(0x08b432, 0x00, 0, -8)
		spawnChildObject(0x08b432, 0x02, 0, 8)
		spawnChildObject(0x08b432, 0x04, -16, -8)
		spawnChildObject(0x08b432, 0x06, 16, -8)
		spawnChildObject(0x08b432, 0x08, -16, 8)
		spawnChildObject(0x08b432, 0x0a, 16, 8)
		spawnChildObject(0x08b432, 0x0c, 0, 0)
		spawnChildObject(0x08b432, 0x0e, 0, 0)
		spawnChildObject(0x08b432, 0x10, 0, 0)
		spawnChildObject(0x08b432, 0x12, 0, 0)
		spawnChildObject(0x08b432, 0x14, 0, 0)
		spawnChildObject(0x08b432, 0x16, 0, 0)

		playSound(0x6e)
		Object.TriggerUnloading()
	}
}


// icz cork floor
//# address-hook(0x02a6d4) end(0x02a7ae)
//# translated(0x02a7e2) end(0x02a848)
function void fn02a6d4()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		// quite frankly, idgaf about these, im just turning them into that one unused object instead
		objA0.update_address = 0x02a502
		if (objA0.subtype2c != 0)
		{
			UnloadObject()
		}
		else
		{
			objA0.subtype2c = 0x1a
			objA0.mapping_offset = 0x229ce0
			objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x0001)
			objA0.box_size.x = 0x10
			objA0.box_size.y = 0x24
			objA0.animation.sprite = objA0.subtype2c & 0x0f
			u32[A0 + 0x3c] = 0x02a884
			objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x03b6)
			objA0.box_size.y = 0x10
		}
		return
	}
	else
	{
		A1 = backup
		base.fn02a6d4()
	}
}

// icz boss platform
//# address-hook(0x071f30) end(0x071f6e)
function void fn071f30()
{
	base.fn071f30()
	
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		u16 charpos_x = objA1.position.x.u16
		u16 charpos_y = objA1.position.y.u16
		
		u16 offset_x = objA0.box_size.x
		u16 offset_y = 16
		
		u16 blockpos_x = objA0.position.x.u16
		u16 blockpos_y = objA0.position.y.u16
		
		bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
		bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
		bool inBoundTop = (charpos_y > blockpos_y - offset_y - 10)
		bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 10)

		if ((inBoundLeft && inBoundRight && inBoundTop && inBoundBottom) && (objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			
			if (objA1.state == 0)
			{
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
				
				playSound(0x49)
					
				A1 = 0xffffb000
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				objA1.velocity.y = -0x300
				objA1.flags2a |= (char.flag.IN_AIR)
				objA1.flags2a &= ~char.flag.ON_OBJECT
				
				if (objA1.state == char.state.TEAIRSLASH)
				{
					objA1.state = char.state.ROLLING
					objA1.groundspeed = 0x800
				}
			}
		}
	}
}

// amogus
//# address-hook(0x025d2c) end(0x025d52)
function void fn025d2c()
{
	base.fn025d2c()
	if (TESonic.isTESonic(A1) && (objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
	{
		objA1.velocity.x = -objA1.velocity.x
		objA1.velocity.y = -objA1.velocity.y
		if (objA1.state == char.state.TEAIRSLASH)
			u16[A1 + 0x3e] = 0
		
		u8[A3] ^= (1 << D3.u8)
		objA0.update_address = addressof(SmallExplosion.BaseUpdate)
		objA0.base_state = 0x02
		u8[A0 + 0x28] = 0
		u8[A0 + 0x29] = 0
	}
}

// lbz pipe wall
//# address-hook(0x027424) end(0x027590)
function void fn027424()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
		objA0.value32 = u16[0xffffb04a + 0x18]
		
		D1.u16 = 0x1b
		D2.u16 = 0x20
		D3.u16 = 0x21
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		A1 = 0xffffb000
		u16 charpos_x = objA1.position.x.u16
		u16 charpos_y = objA1.position.y.u16
		
		u16 offset_x = objA0.box_size.x
		u16 offset_y = objA0.box_size.y
		
		u16 blockpos_x = objA0.position.x.u16
		u16 blockpos_y = objA0.position.y.u16
		
		bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
		bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
		bool inBoundTop = (charpos_y > blockpos_y - offset_y - 20)
		bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 20)

		bool collide = (objA0.flags2a & object.flag.P1_PUSHING && objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480) || ((objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())

		if (!(inBoundLeft && inBoundRight && inBoundTop && inBoundBottom) || !collide)
		{
			DrawOrUnloadObject()
			return
		}

		A1 = 0xffffb000

		if (objA0.flags2a & object.flag.P1_PUSHING)
		{
			objA0.flags2a &= ~object.flag.P1_PUSHING
			u8[0xffffb000 + 0x2a] &= ~char.flag.PUSHING
		}
		objA1.velocity.x = D1.u16

		D0.u16 = objA0.position.x.u16
		if (D0.u16 >= objA1.position.x.u16)
		{
			A4 = 0x027718
			objA1.position.x.u16 -= 4
			
			if (objA1.state != char.state.TEAIRSLASH)
				objA1.velocity.x = -0x200
			else
			{
				objA1.velocity.x = 0x800
				objA1.velocity.x = ((objA1.velocity.x * 3) / 2)
				
				bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
				if (!isHyperSonic)
				{
					// Reduce dash speed for Super Sonic
					objA1.velocity.x = (objA1.velocity.x > 0) ? (objA1.velocity.x - 0x200) : (objA1.velocity.x < 0) ? (objA1.velocity.x + 0x200) : 0
				}
			}
		}
		else
		{
			A4 = 0x0276d8
			objA1.position.x.u16 += 4
			
			if (objA1.state != char.state.TEAIRSLASH)
				objA1.velocity.x = 0x200
			else
			{
				objA1.velocity.x = -0x800
				objA1.velocity.x = ((objA1.velocity.x * 3) / 2)
				
				bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
				if (!isHyperSonic)
				{
					// Reduce dash speed for Super Sonic
					objA1.velocity.x = (objA1.velocity.x > 0) ? (objA1.velocity.x - 0x200) : (objA1.velocity.x < 0) ? (objA1.velocity.x + 0x200) : 0
				}
			}
		}

		objA1.groundspeed = objA1.velocity.x
		D1.u8 = objA0.subtype2c
		if (objA0.subtype2c != 0)
		{
			bool createWaterStream = true

			if (objA0.subtype2c == 0x1f)
			{
				// Let the water rise (in Knuckles' area)
				global.level_flag02 = 1
				water.height.target = 0x0660
				if (super.active)
				{
					water.height.changerate = 2
				}
			}
			else
			{
				// Create the water flow logic (visual effect is separate)
				if (allocDynamicObjectAfterA0())
				{
					objA1.update_address = 0x0295c2
					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16 + 2
					u8[A1 + 0x24] = 0x07
					u8[A1 + 0x2c] = D1.u8
				}
				else
				{
					createWaterStream = false
				}
			}

			if (createWaterStream)
			{
				// Create water stream visual effect
				if (allocDynamicObjectAfterA0())
				{
					objA1.update_address = 0x029896
					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16 - 0x20
					objA1.velocity.y = 1
					u8[A1 + 0x2c] = D1.u8
				}
			}
		}

		objA0.update_address = 0x027592
		fn0275f2()
		fn027592()
	}
	else
	{
		A1 = backup
		base.fn027424()
	}
}

// fbz transition door
//# address-hook(0x070c3c) end(0x070c60)
function void fn070c3c()
{
	base.fn070c3c()

	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (objA0.update_address != 0x070c66)
		{
			Enemy.DrawDynamicObject()
			return
		}

		A2 = A0
		A0 = A1
		
		// kick
		char.flags |= char.flag.IN_AIR
		
		if (char.flags & char.flag.ON_OBJECT)
		{
			char.flags &= ~char.flag.ON_OBJECT
			objA0.position.y.u16 -= 1
		}
		
		u16 acceleration = ((char.flags & char.flag.UNDERWATER) ? 0x080 : 0x200)
		
		u8 angle = char.rotation - 0x40
		s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
		s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

		char.velocity.x += accel_x
		char.velocity.y += accel_y
		char.state = char.state.former
		char.rotation = 0
		char.state = char.state.TEKICK
		char.animation.sprite = 1
		Audio.playAudio("te_kick")
		
		char.velocity.x = -0x500
		A0 = A2
	}
}

// autospin
//# address-hook(0x01e896)
function void fn01e896()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		
		// unload this specific instance of the autospin
		if (global.zone_act.apparent == 0x0401 && level.results_done == 0xff)
		{
			UnloadObject()
			return
		}
	}
	
	A1 = backup
	
	base.fn01e896()
}



// sandwall:tm:
//# address-hook(0x040c2a) end(0x040ce6)
function void fn040c2a()
{
	base.fn040c2a()

	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		D1.u16 = 0x17
		D2.u16 = 0x34
		D3.u16 = 0x35
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		D6 = (D6 << 16) + (D6 >> 16)
		bool crumble = false

		if (D6 & 0x01)
		{
			A1 = 0xffffb000
			crumble = (u8[A1 + 0x20] == char.state.TEKICK || u8[A1 + 0x20] == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject()
		}

		if (D6 & 0x02 && !crumble)
		{
			A1 = 0xffffb04a
			crumble = (u8[A1 + 0x20] == char.state.TEKICK || u8[A1 + 0x20] == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject()
		}

		if (crumble)
		{
			objA1.velocity.x >>= 1
			objA1.groundspeed >>= 1
			
			if (objA1.state == char.state.TEAIRSLASH)
			{
				objA1.state = char.state.ROLLING
				objA1.groundspeed = 0x800
			}

			playSound(0x82)

			objA0.update_address = 0x040cec
			objA0.animation.timer = 5
			objA0.animation.sprite = 1

			A1 = 0xffffb000
			if (objA0.flags2a & object.flag.P1_ON_OBJECT)
			{
				objA0.flags2a &= ~object.flag.P1_ON_OBJECT
				u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
				u8[A1 + 0x2a] |= char.flag.IN_AIR
			}
			else
			{
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
			}


			if (objA0.flags2a & object.flag.P1_PUSHING)
			{
				objA0.flags2a &= ~object.flag.P1_PUSHING
				u8[A1 + 0x2a] &= ~char.flag.PUSHING
			}
		}
	}
}

// sand cork
//# address-hook(0x041d5c) end(0x041df2)
function void fn041d5c()
{
	base.fn041d5c()
	if (TESonic.isTESonic(A1))
	{
		bool kicking = ((u8[A1 + 0x20] == char.state.TEKICK || u8[A1 + 0x20] == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
		if (!kicking)
			return

		objA1.velocity.x = -objA1.velocity.x
		objA1.velocity.y = -objA1.velocity.y
		if (objA1.state == char.state.TEAIRSLASH)
			u16[A1 + 0x3e] = 0
		
		D4.u16 = (objA0.subtype2c & 0x7f) << 4
		D5.u16 = D4.u16
		D3.u16 = objA0.position.y.u16 - 0x90

		while (D5.s16 >= 0)
		{
			fn041e1a()
			D3.u16 -= 0x0100
			D5.u16 -= 0x0100
		}

		u16[A1 + 0x48] = objA0.respawn_entry
		A4 = 0x041e96
		objA0.update_address = 0x041df4

		++objA0.animation.sprite
		objA0.sprite_priority = 0
		playSound(SFX_COLLAPSE)

		fn0216b8()
		UpdateMovementStraightSimple()
		objA0.velocity.y += 0x18

		if (objA0.respawn_entry)
		{
			A2 = 0xffff0000 + objA0.respawn_entry
			u8[A2] |= 0x01
		}

		if (s8[A0 + 0x2c] < 0)
		{
			u16[0xffffeec4] = 0xffff
		}
		else
		{
			u16[0xffffeec6] = 0xffff
		}
		u8[A0 + 0x28] = 0
		u8[A0 + 0x29] = 0
	}
}

// lrz falling spike
//# address-hook(0x042904) end(0x04291a)
function void fn042904()
{
	base.fn042904()
	
	if (TESonic.isTESonic(A1))
	{
		A1 = 0xffffb000
		u16 charpos_x = objA1.position.x.u16
		u16 charpos_y = objA1.position.y.u16
		
		u16 offset_x = objA0.box_size.x
		u16 offset_y = objA0.box_size.y
		
		u16 blockpos_x = objA0.position.x.u16
		u16 blockpos_y = objA0.position.y.u16
		
		bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
		bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
		bool inBoundTop = (charpos_y > blockpos_y - offset_y - 10)
		bool inBoundBottom = (charpos_y < blockpos_y + offset_y + 10)

		if ((inBoundLeft && inBoundRight && inBoundTop && inBoundBottom) && (objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
		{
			objA0.update_address = 0x085102
			objA0.sprite_priority = 0
			objA0.sprite_attributes |= sprite_attribute.PRIORITY
			playSound(0x5d)
			
			bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
			objA0.velocity.x = (onLeft ? 0x400 : -0x400)
			objA0.velocity.y = -0x100
			
			u8[A1 + 0x05] = base_state.NORMAL
			objA1.velocity.x = (onLeft ? -0x200 : 0x200)
			objA1.velocity.y = -0x300
			objA1.flags2a |= (char.flag.IN_AIR)
			objA1.flags2a &= ~char.flag.ON_OBJECT
		}
	}
}

// amogus (impostor)
//# address-hook(0x042ec0) end(0x042ee6)
function void fn042ec0()
{
	base.fn042ec0()
	if (TESonic.isTESonic(A1) && (objA1.state == char.state.TEKICK || objA1.state == char.state.TEAIRSLASH) && TESonic.checkIfKickFacingObject())
	{
		objA1.velocity.x = -objA1.velocity.x
		objA1.velocity.y = -objA1.velocity.y
		if (objA1.state == char.state.TEAIRSLASH)
			u16[A1 + 0x3e] = 0
		u8[A3] |= (1 << D3.u8)
		objA0.update_address = addressof(SmallExplosion.BaseUpdate)
		objA0.base_state = 0x02
		u8[A0 + 0x28] = 0
		u8[A0 + 0x29] = 0
	}
}

// ssz boss 2 behavior
//# address-hook(0x07ac06) end(0x07ac78)
function void fn07ac06()
{
	s16 move_backup = s16[0xfffffaf8]
	base.fn07ac06()
	
	// this is needed otherwise the boss stops moving after taking a hit during the laser phase
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		if (u8[A0 + 0x1c] == 0x1f && u8[A0 + 0x3c] == 0)
		{
			s16[0xfffffaf8] = move_backup
		}
	}
}


// ssz mecha balloon
//# address-hook(0x07aeb0) end(0x07af58)
function void fn07aeb0()
{
	base.fn07aeb0()
	
	A1 = 0xffffb000

	// i guess there's no harm in reusing the cnz ball code?
	if (TESonic.checkIfBallCollidingWithBoss() && ((objA1.state == char.state.TEKICK && TESonic.checkIfKickFacingObject()) || objA1.state == char.state.TEAIRSLASH))
	{
		playSound(0x7b)
		bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
		u8[A1 + 0x05] = base_state.NORMAL
		objA1.state = char.state.TEJUMP
		objA1.velocity.x = (onLeft ? -0x400 : 0x400)
		objA1.velocity.y = -0x300
		objA1.flags2a |= (char.flag.IN_AIR)
		objA1.flags2a &= ~char.flag.ON_OBJECT
		
		A1 = objA0.countdown_callback
		u8[A1 + 0x39] = 0
		++u8[A1 + 0x30]
		--u8[A1 + 0x3c]
		
		if (u8[A1 + 0x3c] == 0)
		{
			s16[0xfffffafa] = -0x180
			if (objA1.flags2e & 0x80)
			{
				s16[0xfffffaf8] = SSZ_MidBoss2.getHorizontalMovementSpeed()
				objA1.render_flags |= render_flag.FLIP_X
			}
			else
			{
				s16[0xfffffaf8] = -SSZ_MidBoss2.getHorizontalMovementSpeed()
				objA1.render_flags &= ~render_flag.FLIP_X
			}
		
			objA1.value26 = 0x0e
			u8[A1 + 0x32] = 0
			objA1.flags2e &= ~0x40
			u8[A1 + 0x33] = 0
			
			A2 = A0
			A0 = A1
			fn07a8da()
			A0 = A2
		}
		else
		{
			objA1.value26 = 0x0a
			s16[0xfffffafa] = -0x180
		}

		objA0.base_state += 2
		u8[A0 + 0x3c] = 0x3c
		objA0.state = 0x02
		objA0.velocity.y = -0x400

		D0.u16 = u16[0xffffb000 + 0x10] - objA0.position.x.u16
		if (objA0.position.x.u16 < 0x16a0)
		{
			D1.u16 = 0x80
		}
		else if (objA0.position.x.u16 >= 0x1760)
		{
			D1.u16 = 0x80
		}
		else
		{
			D1.s16 = (D0.s16 < 0) ? 0x80 : -0x80
		}
		objA0.velocity.x = D1.u16

		if (D1.s16 >= 0)
			objA0.render_flags |= render_flag.FLIP_X
		else
			objA0.render_flags &= ~render_flag.FLIP_X
	}
}

// little spike bot thing in death egg 2 boss
//# address-hook(0x07f900) end(0x07f9a6)
function void fn07f900()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		fn085870()
		if (_equal())
			return

		if (u8[A1 + 0x20] != char.state.ROLLING && (u8[A1 + 0x20] != char.state.TEKICK && u8[A1 + 0x20] != char.state.TEAIRSLASH) && !TESonic.checkIfKickFacingObject())
		{
			if (u8[A1 + 0x34] == 0 && (u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0)
			{
				Enemy.DamageCharacter()
			}
			return
		}

		objA0.base_state = 0x06
		objA0.collision_attributes = (collision.flag.SPECIAL | collision.size.16x16)
		objA0.value42 = 0x07
		objA0.value39 = 0x08

		objA0.velocity.x = objA1.velocity.x

		D4.u16 = 0x800
		if (objA0.render_flags & render_flag.FLIP_Y)
			D4.s16 = -D4.s16
		objA0.velocity.y = D4.u16

		signalMultiReturn()
	}
	else
	{
		A1 = backup
		base.fn07f900()
	}
}

// flying capsule
//# address-hook(0x086770) end(0x0867be)
function void fn086770()
{
	u32 backup = A1
	A1 = 0xffffb000
	if (TESonic.isTESonic(A1))
	{
		A1 = backup
		MoveWithParent()
		fn086a54()

		A1 = 0x0867c2
		fn0858f8()
		if (D0 != 0)
		{
			// Button got pressed
			bool active = false
			if (D0.u16 != 0)
			{
				A1 = 0xffff0000 + D0.u16
				if (objA1.velocity.y < 0)
				{
					active = (objA1.state == char.state.ROLLING || objA1.state == char.state.TEJUMP)
				}
			}

			if (!active)
			{
				D0 = (D0 << 16) + (D0 >> 16)
				A1 = 0xffff0000 + D0.u16
				active = (objA1.velocity.y < 0)
			}

			if (active)
			{
				objA0.update_address = 0x0867ca
				u8[A0 + 0x43] -= 0x08
				A1 = 0xffff0000 + u16[A0 + 0x46]
				u8[A1 + 0x38] |= 0x02
			}
		}
		Child.DrawSprite()
	}
	else
	{
		A1 = backup
		base.fn086770()
	}
}

// master laser
//# address-hook(0x080fa6) end(0x080ff0)
function void fn080fa6()
{
	if (objA0.animation.sprite == 0x1e)
	{
		A1 = 0x080ff2
		fn0858f8()

		u32 backupD0 = D0
		if (D0.u16 != 0)
		{
			A1 = 0xffff0000 + D0.u16
			if (u8[A1 + 0x34] == 0 && (u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0)
			{
				TESonic.health = 0
				A1 = A0
				A0 = 0xffffb000
				TESonic.ZaptheFuckerToDeath()
				A0 = A1
			}
		}
	}
	base.fn080fa6()
}


// stone compat? maybe!
function bool Stone.canFightStoneGapsule()
{
	A1 = 0xffffb000
	// check for base game knux
	if (TESonic.isTESonic(A1) && u8[0xffffe654] == 0)
		return true
		
	return base.Stone.canFightStoneGapsule()
}