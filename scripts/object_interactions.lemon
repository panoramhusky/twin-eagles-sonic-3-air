// rocks
//# address-hook(0x01fd08) end(0x01ff1a)
function void fn01fd08()
{
	u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
	u16[A0 + 0x36] = u16[0xffffb04a + 0x18]

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	D6 = (D6 << 16) + (D6 >> 16)
	if (D6.u16 & 0x03)
	{
		bool canBreakWall = false

		A1 = 0xffffb000
		D1.u16 = u16[A0 + 0x30]
		if (D6.u16 & 0x01)
		{
			if (u8[A1 + 0x38] == CHARACTER_KNUCKLES)
			{
				// Knuckles can break all walls
				canBreakWall = true
			}
			else
			{
				if ((objA0.subtype2c & 0x80) == 0)	// Special Knuckles-only wall?
				{
					if (super.active || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK))
					{
						// Super form breaks walls even when going slow
						canBreakWall = true
					}
					else if ((objA0.flags2a & object.flag.P1_PUSHING) || (u8[A1 + 0x2b] & char.bonus.SHIELD_FIRE))
					{
						// Normal Sonic and Tails need to quickly roll into a wall to break it (this includes the fire shield attack)
						canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x480)
					}
				}
			}

			if (canBreakWall)
			{
				objA0.flags2a &= ~object.flag.P1_PUSHING
				Rocks.BreakWall()

				if (objA0.flags2a & object.flag.P2_PUSHING)
				{
					// Check for second character
					A1 = 0xffffb04a
					if (u8[A1 + 0x38] == CHARACTER_KNUCKLES || objA1.state == char.state.ROLLING)
					{
						objA1.velocity.x = u16[A0 + 0x36]
						objA1.groundspeed = objA1.velocity.x
						objA0.flags2a &= ~object.flag.P2_PUSHING
						objA1.flags2a &= ~char.flag.PUSHING
					}
				}
			}
		}

		if (!canBreakWall)
		{
			// Give second character a try
			A1 = 0xffffb04a
			D1.u16 = u16[A0 + 0x36]

			if (objA0.flags2a & object.flag.P2_PUSHING)
			{
				if (u8[A1 + 0x38] == CHARACTER_KNUCKLES)
				{
					// Knuckles can break all walls
					canBreakWall = true
				}
				else
				{
					if ((objA0.subtype2c & 0x80) == 0)	// Special Knuckles-only wall?
					{
						// Normal Sonic and Tails need to quickly roll into a wall to break it (this includes the fire shield attack)
						canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x480)
					}
				}
			}

			if (canBreakWall)
			{
				objA0.flags2a &= ~object.flag.P2_PUSHING
				Rocks.BreakWall()
				return
			}
		}
	}

	if (competition_mode.active == 0)
	{
		if (checkForUnloadObjectAtPosition(objA0.countdown_value))
			return
	}
	DrawObject()
}

// breakable wall
//# address-hook(0x021568) end(0x021690)
function void fn021568()
{
	u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
	objA0.value32 = u16[0xffffb04a + 0x18]

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	if (u8[A0 + 0x2c] & 0x80)
	{
		if (level.trigger00 == 0)
		{
			DrawOrUnloadObject()
		}
		else
		{
			UnloadObject()
		}
		return
	}

	D6 = (D6 << 16) + (D6 >> 16)
	D6.u16 &= 0x03
	if (D6.u16 == 0)
	{
		DrawOrUnloadObject()
		return
	}

	A1 = 0xffffb000
	D1.u16 = u16[A0 + 0x30]
	if (D6.u16 & 0x01)
	{
		bool canBreakWall = false
		if (super.active || u8[A1 + 0x38] == CHARACTER_KNUCKLES || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK))
		{
			// Super/Hyper forms can break walls, and Knuckles can
			canBreakWall = true
		}
		else
		{
			// Does this wall allow for rolling into the wall? Otherwise the fire shield will do
			if ((objA0.flags2a & object.flag.P1_PUSHING) || (u8[A1 + 0x2b] & char.bonus.SHIELD_FIRE))
			{
				canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
			}
		}

		if (canBreakWall)
		{
			objA0.flags2a &= ~object.flag.P1_PUSHING
			fn02165a()

			A1 = 0xffffb04a
			if ((objA0.flags2a & object.flag.P2_PUSHING) && objA1.state == char.state.ROLLING)
			{
				objA0.flags2a &= ~object.flag.P2_PUSHING
				objA1.velocity.x = objA0.value32
				objA1.groundspeed = objA1.velocity.x
				objA1.flags2a &= ~char.flag.PUSHING
			}

			DrawOrUnloadObject()
			return
		}
	}

	A1 = 0xffffb04a
	D1.u16 = objA0.value32
	if ((objA0.flags2a & object.flag.P2_PUSHING) && objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
	{
		objA0.flags2a &= ~object.flag.P2_PUSHING
		fn02165a()

	#if STANDALONE
		if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2)
		{
			// Prevent slope glitch here for player 1
			if ((u8[0xffffb000 + 0x2a] & char.flag.ON_OBJECT) && u16[0xffffb000 + 0x42] == A0.u16)
			{
				u8[0xffffb000 + 0x2a] &= ~char.flag.ON_OBJECT
				u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
			}
		}
	#endif
	}
#if STANDALONE
	else if (global.zone == 0x02)
	{
		// In MGZ, make all normal breakable walls also breakable by spinning top
		D6 = (D6 << 16) + (D6 >> 16)
		fn021758()
	}
#endif
	else
	{
		DrawOrUnloadObject()
	}
}

// aiz rock thats breakable from the top
//# address-hook(0x01faf2) end(0x01fb4a)
function void Rocks.Update()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC && objA0.subtype2c & 0x01)
	{
		objA0.update_address = 0x01fd08
	}
	else
	{
		base.Rocks.Update()
	}
}

// MGZ spin dash wheel
//# address-hook(0x025d9c) end(0x025ea0)
function void fn025d9c()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		D1.u16 = 0x1b
		D2.u16 = 0x10
		D4.u16 = objA0.position.x.u16
		A2 = 0x025f0e
		fn01dd0e()

		D6 = (D6 << 16) + (D6 >> 16)
		D6.u16 &= 0x33
		if (D6.u16 != 0)
		{
			D0.u8 = D6.u8 & 0x11
			if (D0.u8 != 0)
			{
				A1 = 0xffffb000
				if (objA1.state == char.state.TEKICK && objA1.animation.sprite == 3)
				{
					u16[A0 + 0x30] = 0x3c
					u8[A0 + 0x32] = 1
					D0.u8 = (u8[A1 + 0x2a] + objA0.flags2a) & 0x01
					if (D0.u8 == 0)
					{
						u8[A0 + 0x32] = 0xff
					}
					
					if (objA1.state.former == char.state.TEKICK)
						objA1.state = char.state.GOT_HURT_PANIC
				}
			}

			D6.u8 &= 0x22
			if (D6.u8 != 0)
			{
				A1 = 0xffffb04a
			#if STANDALONE
				if (objA1.state == char.state.SPINDASH || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state.former == char.state.SONIC_DROPDASH))
			#else
				if (objA1.state == char.state.SPINDASH)
			#endif
				{
					u16[A0 + 0x30] = 0x3c
					u8[A0 + 0x32] = 1
					D0.u8 = (u8[A1 + 0x2a] + objA0.flags2a) & 0x01
					if (D0.u8 == 0)
					{
						u8[A0 + 0x32] = 0xff
					}
				}
			}
		}

		if (u16[A0 + 0x30] != 0)
		{
			D0.u16 = objA0.subtype2c & 0x0f
			A3 = 0xfffff7e0 + D0.u16

			--u16[A0 + 0x30]
			if (u16[A0 + 0x30] == 0)
			{
				u8[A3] = 0
				objA0.animation.sprite = 0
			}
			else
			{
				u8[A3] = 1
				if (objA0.flags2a & object.flag.P1_ON_OBJECT)
				{
					A1 = 0xffffb000
					fn025ea6()
				}
				if (objA0.flags2a & object.flag.P2_ON_OBJECT)
				{
					A1 = 0xffffb04a
					fn025ea6()
				}

				--objA0.animation.timer
				if (s8(objA0.animation.timer) < 0)
				{
					objA0.animation.timer = 1
					objA0.compound.sprite1.animation.sprite = (objA0.compound.sprite1.animation.sprite + u8[A0 + 0x32]) & 0x03
				}
				objA0.animation.sprite = (objA0.animation.sprite != 0) ? 0 : 4
			}
		}
		
		DrawOrUnloadObject()
	}
	else
	{
		base.fn025d9c()
	}
}

// cork floor >:(
//# address-hook(0x02a502) end(0x02a586)
function void fn02a502()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		u16[A0 + 0x38] = score.bonus_counter
		u8[A0 + 0x34] = u8[0xffffb000 + 0x20]
		u8[A0 + 0x36] = u8[0xffffb04a + 0x20]
		D1 = objA0.box_size.x + 11
		D2 = objA0.box_size.y
		D3.u16 = D2.u16 + 1
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		D0.u16 = objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)
		if (D0.u16 == 0)
		{
			DrawOrUnloadObject()
			return
		}

		if (D0.u8 == (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT))
		{
			if (u8[A0 + 0x34] != 2 && u8[A0 + 0x36] != 2)
			{
				DrawOrUnloadObject()
				return
			}

			A1 = 0xffffb000
			D0.u8 = u8[A0 + 0x34]
			fn02a588()

			A1 = 0xffffb04a
			D0.u8 = u8[A0 + 0x36]
			fn02a588()

			fn02a5d8()
		}
		else
		{
			D1.u8 = D0.u8 & object.flag.P1_ON_OBJECT
			if (D1.u8 == 0)
			{
				fn02a5c0()
				return
			}

			if (u8[A0 + 0x34] != char.state.TEJUMP)
			{
				DrawOrUnloadObject()
				return
			}

			A1 = 0xffffb000
			fn02a58e()
			fn02a5d8()
		}
	}
	else
	{
		base.fn02a502()
	}
}

// oughhh more cork floor >:((
//# address-hook(0x02a58e)
function void fn02a58e()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEJUMP)
	{
		objA1.flags2a |= char.flag.IN_AIR
		objA1.flags2a &= ~char.flag.ON_OBJECT
		objA1.velocity.y = -0x300
		u8[A1 + 0x05] = base_state.NORMAL
	}
	else
	{
		base.fn02a58e()
	}
}

// cnz button
function void Button.checkIfPressed()
{
	base.Button.checkIfPressed()
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		// This points to one of "level.trigger00" ... "level.trigger0f"
		A3 = 0xfffff7e0 + (objA0.subtype2c & 0x0f)

		if ((objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)) && objA0.subtype2c == 0x00 && global.zone_act.apparent == 0x0301)
		{
			// Button is pressed
			if (u8[A3] == 0)
			{
				playSound(SFX_CLICK)
			}
			
			objA0.update_address = addressof(SmallExplosion.BaseUpdate)
			objA0.base_state = 0x02
			u8[A0 + 0x28] = 0
			u8[A0 + 0x29] = 0
			
			objA1.flags2a &= ~char.flag.ON_OBJECT
		}
	}
}

// icz ice jenga
//# translated(0x08ac80) end(0x08accc)
function bool fn08ac80()
{
	u8 bit = (1 << D1.u8)

	u16 charpos_x = objA1.position.x.u16
	u16 charpos_y = objA1.position.y.u16
	
	u16 blockpos_x = objA0.position.x.u16
	u16 blockpos_y = objA0.position.y.u16
	
	u16 offset_x = objA0.box_size.x
	u16 offset_y = objA0.box_size.y
	
	bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
	bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
	bool inBoundTop = (charpos_y > blockpos_y - offset_y)
	bool inBoundBottom = (charpos_y > blockpos_y - offset_y)

	if (inBoundLeft && inBoundRight && inBoundTop && inBoundBottom)
	{
		bool TEKick = ((u8[A1 + 0x38] == CHARACTER_SONIC) && objA1.state == char.state.TEKICK && objA1.animation.sprite == 0x04)
	
		// To break through, the character needs to kick it
		if (TEKick)
		{
			if (objA0.value3a >= 1)
			{
				u8[A1 + 0x2a] &= ~bit

				objA0.flags2a &= ~bit
				objA0.flags38 |= 0x01

				// "spawnChildObjects(0x08aaea)" replaced by:
				spawnChildObject(0x08a8dc, 0x00, -12, -8)
				spawnChildObject(0x08a8dc, 0x02, -4, -8)
				spawnChildObject(0x08a8dc, 0x04, 4, -8)
				spawnChildObject(0x08a8dc, 0x06, 12, -8)
				spawnChildObject(0x08a8dc, 0x08, -12, 0)
				spawnChildObject(0x08a8dc, 0x0a, -4, 0)
				spawnChildObject(0x08a8dc, 0x0c, 4, 0)
				spawnChildObject(0x08a8dc, 0x0e, 12, 0)
				spawnChildObject(0x08a8dc, 0x10, -12, 8)
				spawnChildObject(0x08a8dc, 0x12, -4, 8)
				spawnChildObject(0x08a8dc, 0x14, 4, 8)
				spawnChildObject(0x08a8dc, 0x16, 12, 8)

				fn08594e()
				Object.TriggerUnloading()
				playSound(SFX_COLLAPSE)
				return true
			}
			else
			{
				bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
			
				if (objA0.value3a == 0)
				{
					playSound(0x5d)
				}
				
				objA1.velocity.x = (onLeft ? -0x200 : 0x200)
				
				objA0.position.x.u16 += (onLeft ? 0x08 : -0x08)
				
				objA0.value3a += 1
			}
		}
	}
	
	return base.fn08ac80()
}

// icz ice block
//# address-hook(0x08b384) end(0x08b3a4)
function void fn08b384()
{
	base.fn08b384()
	
	D6 = (D6 << 16) + (D6 >> 16)
	if (D6.u16 & 0x03)
	{
		A1 = 0xffffb000
		if (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK)
		{
			bool onLeft = (objA1.position.x.u16 < objA0.position.x.u16)
			u8[A1 + 0x05] = base_state.NORMAL
			objA1.velocity.x = (onLeft ? -0x200 : 0x200)
			objA1.velocity.y = -0x300
			objA1.flags2a |= (char.flag.IN_AIR)
			objA1.flags2a &= ~char.flag.ON_OBJECT

			if (A2 != 0)
			{
				u8[A2 + 0x2a] |= char.flag.IN_AIR
				u8[A2 + 0x2a] &= ~char.flag.ON_OBJECT
			}

			// Spawn broken ice block chunks
			// "spawnChildObjects(0x08b480)" replaced by:
			spawnChildObject(0x08b432, 0x00, 0, -8)
			spawnChildObject(0x08b432, 0x02, 0, 8)
			spawnChildObject(0x08b432, 0x04, -16, -8)
			spawnChildObject(0x08b432, 0x06, 16, -8)
			spawnChildObject(0x08b432, 0x08, -16, 8)
			spawnChildObject(0x08b432, 0x0a, 16, 8)
			spawnChildObject(0x08b432, 0x0c, 0, 0)
			spawnChildObject(0x08b432, 0x0e, 0, 0)
			spawnChildObject(0x08b432, 0x10, 0, 0)
			spawnChildObject(0x08b432, 0x12, 0, 0)
			spawnChildObject(0x08b432, 0x14, 0, 0)
			spawnChildObject(0x08b432, 0x16, 0, 0)

			playSound(0x6e)
			Object.TriggerUnloading()
		}
	}
}

// icz cork floor
//# address-hook(0x02a6d4) end(0x02a7ae)
//# translated(0x02a7e2) end(0x02a848)
function void fn02a6d4()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		// quite frankly, idgaf about these, im making them just cause the player to autospin instead
		objA0.update_address = 0x02a502
		if (objA0.subtype2c != 0)
		{
			UnloadObject()
		}
		else
		{
			objA0.subtype2c = 0x1a
			objA0.mapping_offset = 0x229ce0
			objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x0001)
			objA0.box_size.x = 0x10
			objA0.box_size.y = 0x24
			objA0.animation.sprite = objA0.subtype2c & 0x0f
			u32[A0 + 0x3c] = 0x02a884
			objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x03b6)
			objA0.box_size.y = 0x10
		}
		return
	}
	else
	{
		base.fn02a6d4()
	}
}

// amogus
//# address-hook(0x025d2c) end(0x025d52)
function void fn025d2c()
{
	base.fn025d2c()
	if (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK)
	{
		objA1.velocity.x = -objA1.velocity.x
		objA1.velocity.y = -objA1.velocity.y
		u8[A3] ^= (1 << D3.u8)
		objA0.update_address = addressof(SmallExplosion.BaseUpdate)
		objA0.base_state = 0x02
		u8[A0 + 0x28] = 0
		u8[A0 + 0x29] = 0
	}
}

// lbz pipe wall
//# address-hook(0x027424) end(0x027590)
function void fn027424()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
		objA0.value32 = u16[0xffffb04a + 0x18]
		
		D1.u16 = 0x1b
		D2.u16 = 0x20
		D3.u16 = 0x21
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		A1 = 0xffffb000
		u16 charpos_x = objA1.position.x.u16
		u16 charpos_y = objA1.position.y.u16
		
		u16 blockpos_x = objA0.position.x.u16
		u16 blockpos_y = objA0.position.y.u16
		
		u16 offset_x = objA0.box_size.x
		u16 offset_y = objA0.box_size.y
		
		bool inBoundLeft = (charpos_x > blockpos_x - offset_x - 20)
		bool inBoundRight = (charpos_x < blockpos_x + offset_x + 20)
		bool inBoundTop = (charpos_y > blockpos_y - offset_y)
		bool inBoundBottom = (charpos_y > blockpos_y - offset_y)

		if (!(inBoundLeft && inBoundRight && inBoundTop && inBoundBottom))
		{
			DrawOrUnloadObject()
			return
		}

		A1 = 0xffffb000
		D1.u16 = u16[A0 + 0x30]
		if ((objA0.flags2a & object.flag.P1_PUSHING && objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480) || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK))
		{
			if (objA0.flags2a & object.flag.P2_PUSHING)
			{
				objA0.flags2a &= ~object.flag.P2_PUSHING

				A2 = 0xffffb04a
				u8[A2 + 0x2a] &= ~char.flag.PUSHING
				if ((u8[A2 + 0x20] == char.state.ROLLING) || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK))
				{
					u16[A2 + 0x18] = objA0.value32
					u16[A2 + 0x1c] = u16[A2 + 0x18]
				}
			}
		}
		else
		{
			A1 = 0xffffb04a
			D1.u16 = objA0.value32
			if (((objA0.flags2a & object.flag.P2_PUSHING) == 0 || u8[A1 + 0x20] != char.state.ROLLING || abs(D1.s16) < 0x0480) || !(u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state == char.state.TEKICK))
			{
				DrawOrUnloadObject()
				return
			}

			if (objA0.flags2a & object.flag.P2_PUSHING)	// Isn't this always true here?
			{
				objA0.flags2a &= ~object.flag.P2_PUSHING
				u8[0xffffb04a + 0x2a] &= ~char.flag.PUSHING
			}
		}

		if (objA0.flags2a & object.flag.P1_PUSHING)
		{
			objA0.flags2a &= ~object.flag.P1_PUSHING
			u8[0xffffb000 + 0x2a] &= ~char.flag.PUSHING
		}
		objA1.velocity.x = D1.u16

		D0.u16 = objA0.position.x.u16
		if (D0.u16 >= objA1.position.x.u16)
		{
			A4 = 0x027718
			objA1.position.x.u16 -= 4
		}
		else
		{
			A4 = 0x0276d8
			objA1.position.x.u16 += 4
		}

		objA1.groundspeed = objA1.velocity.x
		D1.u8 = objA0.subtype2c
		if (objA0.subtype2c != 0)
		{
			bool createWaterStream = true

			if (objA0.subtype2c == 0x1f)
			{
				// Let the water rise (in Knuckles' area)
				global.level_flag02 = 1
				water.height.target = 0x0660
				if (super.active)
				{
					water.height.changerate = 2
				}
			}
			else
			{
				// Create the water flow logic (visual effect is separate)
				if (allocDynamicObjectAfterA0())
				{
					objA1.update_address = 0x0295c2
					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16 + 2
					u8[A1 + 0x24] = 0x07
					u8[A1 + 0x2c] = D1.u8
				}
				else
				{
					createWaterStream = false
				}
			}

			if (createWaterStream)
			{
				// Create water stream visual effect
				if (allocDynamicObjectAfterA0())
				{
					objA1.update_address = 0x029896
					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16 - 0x20
					objA1.velocity.y = 1
					u8[A1 + 0x2c] = D1.u8
				}
			}
		}

		objA0.update_address = 0x027592
		fn0275f2()
		fn027592()
	}
	else
	{
		base.fn027424()
	}
}

// flying capsule
//# address-hook(0x086770) end(0x0867be)
function void fn086770()
{
	A1 = 0xffffb000
	if (u8[A1 + 0x38] == CHARACTER_SONIC)
	{
		MoveWithParent()
		fn086a54()

		A1 = 0x0867c2
		fn0858f8()
		if (D0 != 0)
		{
			// Button got pressed
			bool active = false
			if (D0.u16 != 0)
			{
				A1 = 0xffff0000 + D0.u16
				if (objA1.velocity.y < 0)
				{
					active = (u8[A1 + 0x20] == char.state.ROLLING || u8[A1 + 0x38] == CHARACTER_TAILS) || (u8[A1 + 0x38] == 0 && objA1.state == char.state.TEJUMP)
				}
			}

			if (!active)
			{
				D0 = (D0 << 16) + (D0 >> 16)
				A1 = 0xffff0000 + D0.u16
				active = (objA1.velocity.y < 0)
			}

			if (active)
			{
				objA0.update_address = 0x0867ca
				u8[A0 + 0x43] -= 0x08
				A1 = 0xffff0000 + u16[A0 + 0x46]
				u8[A1 + 0x38] |= 0x02
			}
		}
		Child.DrawSprite()
	}
	else
	{
		base.fn086770()
	}
}