constant u8 char.state.TEJUMP = 0x40
constant u8 char.state.TEKICK = 0x41
constant u8 char.state.TEAIRSLASH = 0x42
constant u8 char.state.TEFUCKINGDIED = 0x43

//# address-hook(0x012600) end(0x01286c)
//# translated(0x012a2a) end(0x012a6e)
function void UpdateSonicAnimation()
{
	if (TESonic.isTESonic(A0))
	{
		if (char.state != char.state.former)
		{
			char.state.former = char.state
			char.animation.frame = 0
			char.animation.timer = 0
			char.flags &= ~char.flag.PUSHING
		}

	#if STANDALONE
		A1 = (super.active && char.state <= char.state.TRANSFORMING) ? 0x012c3a : 0x012aa6		// Fixed Super Sonic missing some animation states
	#else
		A1 = (super.active) ? 0x012c3a : 0x012aa6
	#endif
		A1 = tableLookupAddress(A1, char.state * 2)
		D0.u8 = u8[A1]

		// D0.u8 is either:
		//  - 0xff when running
		//  - 0xfe when rolling (on ground or in air)
		//  - between 0x00 and 0x7f in other cases (like standing, balancing, spring-jumping, getting hurt, etc.)

		
		if (char.state == char.state.TEJUMP)
		{
			D1.u8 = char.flags & char.flag.FACING_LEFT
			char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
			char.animation.sprite = 0x8e
				
			if ((char.flags & char.flag.IN_AIR) == 0)
				char.state = char.state.RUNNING
		}
		else if (char.state == char.state.TEKICK)
		{
			D1.u8 = char.flags & char.flag.FACING_LEFT
			char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
		
			constant array<u8> KICK =
			{
				1, 1, 1, 1, 1,
				2, 2, 2, 2, 2,
				3, 3, 3, 3, 3,
				4, 4, 4, 4, 4,
				0,
			}
			++char.animation.timer
		
			if (char.animation.timer > 19)
			{
				if ((char.flags & char.flag.IN_AIR) == 0)
					char.state = char.state.RUNNING
				else
					char.state = char.state.TEJUMP
				
				char.rotation.x = 0
			}
			else
				char.animation.sprite = KICK[char.animation.timer]
		}
		else if (char.state == char.state.TEAIRSLASH)
		{
			if (super.active)
				TESonic.UpdateAirSlashAnim()
			else
				char.state = char.state.TRANSFORMING
		}
		else if (char.state == char.state.TEFUCKINGDIED)
		{
			D1.u8 = char.flags & char.flag.FACING_LEFT
			char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | D1.u8
			
			if (char.velocity.x != 0)
			{
				char.animation.sprite = 0x8d
				return
			}
		
			constant array<u8> FUCKINGDEAD =
			{
				0xbf, 0xbf, 0xbf, 0xbf,
				0xbf, 0xbf, 0xbf, 0xbf,
				0xbf, 0xbf, 0xbf, 0xbf,
				0xbf, 0xbf, 0xbf, 0xbf,
				0xbf, 0xbf, 0xbf, 0xbf,
				0xc0, 0xc0, 0xc0, 0xc0,
				0xc0, 0xc0, 0xc0, 0xc0,
				0xc0, 0xc0, 0xc0, 0xc0,
				0xc0, 0xc0, 0xc0, 0xc0,
				0xc0, 0xc0, 0xc0, 0xc0,
				0xc1, 0xc1, 0xc1, 0xc1,
				0xc1, 0xc1, 0xc1, 0xc1,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc2, 0xc2, 0xc2, 0xc2,
				0xc1, 0xc1, 0xc1, 0xc1,
				0xc1, 0xc1, 0xc1, 0xc1,
				0xbf, 0xbf, 0xbf, 0xbf,
			}
			++char.animation.timer
		
			if (char.animation.timer > 167)
			{
				char.base_state = 0x02
				char.state = char.state.STANDING
				char.invuln.countdown = 0
				char.velocity.x = 0
				char.flags = 0
			}
			else
				char.animation.sprite = FUCKINGDEAD[char.animation.timer]
		}
		else if (D0.u8 < 0x80)
		{
			updateSonicAnimationStanding()
		}
		else if (D0.u8 == 0xff)
		{
			updateSonicAnimationRunning()
		}
		else // if (D0.u8 == 0xfe)
		{
			updateSonicAnimationRolling()
		}
	}
	else
	{
		base.UpdateSonicAnimation()
	}
}

function void TESonic.UpdateAirSlashAnim()
{
	char.rotation = lookupAngleByVector(char.velocity.x, char.velocity.y)
	
	if (char.flags & char.flag.FACING_LEFT)
		char.rotation -= 0x80

	D0.u8 = (s8(char.rotation) > 0) ? (char.rotation - 1) : char.rotation
	D2.u8 = char.flags & char.flag.FACING_LEFT
	if (D2.u8 == 0)
		D0.s8 = -D0.s8 - 1

	D0.u8 += 0x10
	D1 = (D0.u8 & 0x80) ? (render_flag.FLIP_X | render_flag.FLIP_Y) : 0
	D2.u8 ^= D1.u8

	char.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
	char.render_flags |= D2.u8
	
	D0.u8 = (D0.u8 >> 4) & 0x06
		
	// Super Sonic's running animation
	A1 = 0x012c84
	D3.u8 = D0.u8 * 2
	
	D0.u8 = u8[A1 + char.animation.frame + 1]	// Load next animation frame byte
	if (D0.u8 >= 0xfe)		// 0xfe is possible in rare cases when Sonic touches ground while being carried by Tails
	{
		// Loop animation from the start
		char.animation.frame = 0
		D0.u8 = u8[A1 + 1]
	}

	char.animation.sprite = D0.u8 + D3.u8		// Change sprites based on rotations
	++char.animation.frame
}

/*
function void updateSonicAnimationRunning()
{
	if (TESonic.isTESonic(A0))
	{
		A1 = 0xffffb000
		A6 = 0xffffcc54
		if (objA0.state == char.state.RUNNING && (char.flags & char.flag.UNDERWATER) == 0)
		{
			u8[A6 + 0x05] = 0x06		// Base update for braking dust
			u8[A6 + 0x22] = 0x15		// First frame of dust animation
		}
	}
	base.updateSonicAnimationRunning()
}
*/